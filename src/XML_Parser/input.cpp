// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "input.h"

// bodyType
// 

bodyType::
bodyType (value v)
: ::xml_schema::string (_xsd_bodyType_literals_[v])
{
}

bodyType::
bodyType (const char* v)
: ::xml_schema::string (v)
{
}

bodyType::
bodyType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

bodyType::
bodyType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

bodyType::
bodyType (const bodyType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

bodyType& bodyType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_bodyType_literals_[v]);

  return *this;
}


// calcType
// 

calcType::
calcType (value v)
: ::xml_schema::string (_xsd_calcType_literals_[v])
{
}

calcType::
calcType (const char* v)
: ::xml_schema::string (v)
{
}

calcType::
calcType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

calcType::
calcType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

calcType::
calcType (const calcType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

calcType& calcType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_calcType_literals_[v]);

  return *this;
}


// particleContainerType
// 

particleContainerType::
particleContainerType (value v)
: ::xml_schema::string (_xsd_particleContainerType_literals_[v])
{
}

particleContainerType::
particleContainerType (const char* v)
: ::xml_schema::string (v)
{
}

particleContainerType::
particleContainerType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

particleContainerType::
particleContainerType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

particleContainerType::
particleContainerType (const particleContainerType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

particleContainerType& particleContainerType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_particleContainerType_literals_[v]);

  return *this;
}


// yesNo
// 

yesNo::
yesNo (value v)
: ::xml_schema::string (_xsd_yesNo_literals_[v])
{
}

yesNo::
yesNo (const char* v)
: ::xml_schema::string (v)
{
}

yesNo::
yesNo (const ::std::string& v)
: ::xml_schema::string (v)
{
}

yesNo::
yesNo (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

yesNo::
yesNo (const yesNo& v,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

yesNo& yesNo::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_yesNo_literals_[v]);

  return *this;
}


// parallelType
// 

parallelType::
parallelType (value v)
: ::xml_schema::string (_xsd_parallelType_literals_[v])
{
}

parallelType::
parallelType (const char* v)
: ::xml_schema::string (v)
{
}

parallelType::
parallelType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

parallelType::
parallelType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

parallelType::
parallelType (const parallelType& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

parallelType& parallelType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_parallelType_literals_[v]);

  return *this;
}


// boundaryCondition
// 

boundaryCondition::
boundaryCondition (value v)
: ::xml_schema::string (_xsd_boundaryCondition_literals_[v])
{
}

boundaryCondition::
boundaryCondition (const char* v)
: ::xml_schema::string (v)
{
}

boundaryCondition::
boundaryCondition (const ::std::string& v)
: ::xml_schema::string (v)
{
}

boundaryCondition::
boundaryCondition (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

boundaryCondition::
boundaryCondition (const boundaryCondition& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

boundaryCondition& boundaryCondition::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_boundaryCondition_literals_[v]);

  return *this;
}


// dimensionType
// 

dimensionType::
dimensionType (value v)
: ::xml_schema::string (_xsd_dimensionType_literals_[v])
{
}

dimensionType::
dimensionType (const char* v)
: ::xml_schema::string (v)
{
}

dimensionType::
dimensionType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

dimensionType::
dimensionType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

dimensionType::
dimensionType (const dimensionType& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

dimensionType& dimensionType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_dimensionType_literals_[v]);

  return *this;
}


// bodyState
// 

bodyState::
bodyState (value v)
: ::xml_schema::string (_xsd_bodyState_literals_[v])
{
}

bodyState::
bodyState (const char* v)
: ::xml_schema::string (v)
{
}

bodyState::
bodyState (const ::std::string& v)
: ::xml_schema::string (v)
{
}

bodyState::
bodyState (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

bodyState::
bodyState (const bodyState& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

bodyState& bodyState::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_bodyState_literals_[v]);

  return *this;
}


// thermostatType
// 

thermostatType::
thermostatType (value v)
: ::xml_schema::string (_xsd_thermostatType_literals_[v])
{
}

thermostatType::
thermostatType (const char* v)
: ::xml_schema::string (v)
{
}

thermostatType::
thermostatType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

thermostatType::
thermostatType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

thermostatType::
thermostatType (const thermostatType& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

thermostatType& thermostatType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_thermostatType_literals_[v]);

  return *this;
}


// gravDirectionType
// 

gravDirectionType::
gravDirectionType (value v)
: ::xml_schema::string (_xsd_gravDirectionType_literals_[v])
{
}

gravDirectionType::
gravDirectionType (const char* v)
: ::xml_schema::string (v)
{
}

gravDirectionType::
gravDirectionType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

gravDirectionType::
gravDirectionType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

gravDirectionType::
gravDirectionType (const gravDirectionType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

gravDirectionType& gravDirectionType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_gravDirectionType_literals_[v]);

  return *this;
}


// generalParams
// 

const generalParams::t_end_type& generalParams::
t_end () const
{
  return this->t_end_.get ();
}

generalParams::t_end_type& generalParams::
t_end ()
{
  return this->t_end_.get ();
}

void generalParams::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const generalParams::delta_t_type& generalParams::
delta_t () const
{
  return this->delta_t_.get ();
}

generalParams::delta_t_type& generalParams::
delta_t ()
{
  return this->delta_t_.get ();
}

void generalParams::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const generalParams::writeFrequency_type& generalParams::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

generalParams::writeFrequency_type& generalParams::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void generalParams::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}

const generalParams::dimensionType_type& generalParams::
dimensionType () const
{
  return this->dimensionType_.get ();
}

generalParams::dimensionType_type& generalParams::
dimensionType ()
{
  return this->dimensionType_.get ();
}

void generalParams::
dimensionType (const dimensionType_type& x)
{
  this->dimensionType_.set (x);
}

void generalParams::
dimensionType (::std::unique_ptr< dimensionType_type > x)
{
  this->dimensionType_.set (std::move (x));
}

const generalParams::parallelType_type& generalParams::
parallelType () const
{
  return this->parallelType_.get ();
}

generalParams::parallelType_type& generalParams::
parallelType ()
{
  return this->parallelType_.get ();
}

void generalParams::
parallelType (const parallelType_type& x)
{
  this->parallelType_.set (x);
}

void generalParams::
parallelType (::std::unique_ptr< parallelType_type > x)
{
  this->parallelType_.set (std::move (x));
}

const generalParams::g_grav_type& generalParams::
g_grav () const
{
  return this->g_grav_.get ();
}

generalParams::g_grav_type& generalParams::
g_grav ()
{
  return this->g_grav_.get ();
}

void generalParams::
g_grav (const g_grav_type& x)
{
  this->g_grav_.set (x);
}

const generalParams::useGravity_type& generalParams::
useGravity () const
{
  return this->useGravity_.get ();
}

generalParams::useGravity_type& generalParams::
useGravity ()
{
  return this->useGravity_.get ();
}

void generalParams::
useGravity (const useGravity_type& x)
{
  this->useGravity_.set (x);
}

void generalParams::
useGravity (::std::unique_ptr< useGravity_type > x)
{
  this->useGravity_.set (std::move (x));
}

const generalParams::gravDirection_type& generalParams::
gravDirection () const
{
  return this->gravDirection_.get ();
}

generalParams::gravDirection_type& generalParams::
gravDirection ()
{
  return this->gravDirection_.get ();
}

void generalParams::
gravDirection (const gravDirection_type& x)
{
  this->gravDirection_.set (x);
}

void generalParams::
gravDirection (::std::unique_ptr< gravDirection_type > x)
{
  this->gravDirection_.set (std::move (x));
}

const generalParams::calcType_type& generalParams::
calcType () const
{
  return this->calcType_.get ();
}

generalParams::calcType_type& generalParams::
calcType ()
{
  return this->calcType_.get ();
}

void generalParams::
calcType (const calcType_type& x)
{
  this->calcType_.set (x);
}

void generalParams::
calcType (::std::unique_ptr< calcType_type > x)
{
  this->calcType_.set (std::move (x));
}

const generalParams::baseNameOutputFiles_type& generalParams::
baseNameOutputFiles () const
{
  return this->baseNameOutputFiles_.get ();
}

generalParams::baseNameOutputFiles_type& generalParams::
baseNameOutputFiles ()
{
  return this->baseNameOutputFiles_.get ();
}

void generalParams::
baseNameOutputFiles (const baseNameOutputFiles_type& x)
{
  this->baseNameOutputFiles_.set (x);
}

void generalParams::
baseNameOutputFiles (::std::unique_ptr< baseNameOutputFiles_type > x)
{
  this->baseNameOutputFiles_.set (std::move (x));
}

const generalParams::particleContainerType_type& generalParams::
particleContainerType () const
{
  return this->particleContainerType_.get ();
}

generalParams::particleContainerType_type& generalParams::
particleContainerType ()
{
  return this->particleContainerType_.get ();
}

void generalParams::
particleContainerType (const particleContainerType_type& x)
{
  this->particleContainerType_.set (x);
}

void generalParams::
particleContainerType (::std::unique_ptr< particleContainerType_type > x)
{
  this->particleContainerType_.set (std::move (x));
}

const generalParams::cutoffRadius_type& generalParams::
cutoffRadius () const
{
  return this->cutoffRadius_.get ();
}

generalParams::cutoffRadius_type& generalParams::
cutoffRadius ()
{
  return this->cutoffRadius_.get ();
}

void generalParams::
cutoffRadius (const cutoffRadius_type& x)
{
  this->cutoffRadius_.set (x);
}

const generalParams::gravInput_type& generalParams::
gravInput () const
{
  return this->gravInput_.get ();
}

generalParams::gravInput_type& generalParams::
gravInput ()
{
  return this->gravInput_.get ();
}

void generalParams::
gravInput (const gravInput_type& x)
{
  this->gravInput_.set (x);
}

void generalParams::
gravInput (::std::unique_ptr< gravInput_type > x)
{
  this->gravInput_.set (std::move (x));
}

const generalParams::loadCheckpoint_type& generalParams::
loadCheckpoint () const
{
  return this->loadCheckpoint_.get ();
}

generalParams::loadCheckpoint_type& generalParams::
loadCheckpoint ()
{
  return this->loadCheckpoint_.get ();
}

void generalParams::
loadCheckpoint (const loadCheckpoint_type& x)
{
  this->loadCheckpoint_.set (x);
}

void generalParams::
loadCheckpoint (::std::unique_ptr< loadCheckpoint_type > x)
{
  this->loadCheckpoint_.set (std::move (x));
}

const generalParams::makeCheckpoint_type& generalParams::
makeCheckpoint () const
{
  return this->makeCheckpoint_.get ();
}

generalParams::makeCheckpoint_type& generalParams::
makeCheckpoint ()
{
  return this->makeCheckpoint_.get ();
}

void generalParams::
makeCheckpoint (const makeCheckpoint_type& x)
{
  this->makeCheckpoint_.set (x);
}

void generalParams::
makeCheckpoint (::std::unique_ptr< makeCheckpoint_type > x)
{
  this->makeCheckpoint_.set (std::move (x));
}

const generalParams::pathInCheckpoint_type& generalParams::
pathInCheckpoint () const
{
  return this->pathInCheckpoint_.get ();
}

generalParams::pathInCheckpoint_type& generalParams::
pathInCheckpoint ()
{
  return this->pathInCheckpoint_.get ();
}

void generalParams::
pathInCheckpoint (const pathInCheckpoint_type& x)
{
  this->pathInCheckpoint_.set (x);
}

void generalParams::
pathInCheckpoint (::std::unique_ptr< pathInCheckpoint_type > x)
{
  this->pathInCheckpoint_.set (std::move (x));
}

const generalParams::pathOutCheckpoint_type& generalParams::
pathOutCheckpoint () const
{
  return this->pathOutCheckpoint_.get ();
}

generalParams::pathOutCheckpoint_type& generalParams::
pathOutCheckpoint ()
{
  return this->pathOutCheckpoint_.get ();
}

void generalParams::
pathOutCheckpoint (const pathOutCheckpoint_type& x)
{
  this->pathOutCheckpoint_.set (x);
}

void generalParams::
pathOutCheckpoint (::std::unique_ptr< pathOutCheckpoint_type > x)
{
  this->pathOutCheckpoint_.set (std::move (x));
}

const generalParams::domainSizeX_type& generalParams::
domainSizeX () const
{
  return this->domainSizeX_.get ();
}

generalParams::domainSizeX_type& generalParams::
domainSizeX ()
{
  return this->domainSizeX_.get ();
}

void generalParams::
domainSizeX (const domainSizeX_type& x)
{
  this->domainSizeX_.set (x);
}

const generalParams::domainSizeY_type& generalParams::
domainSizeY () const
{
  return this->domainSizeY_.get ();
}

generalParams::domainSizeY_type& generalParams::
domainSizeY ()
{
  return this->domainSizeY_.get ();
}

void generalParams::
domainSizeY (const domainSizeY_type& x)
{
  this->domainSizeY_.set (x);
}

const generalParams::domainSizeZ_type& generalParams::
domainSizeZ () const
{
  return this->domainSizeZ_.get ();
}

generalParams::domainSizeZ_type& generalParams::
domainSizeZ ()
{
  return this->domainSizeZ_.get ();
}

void generalParams::
domainSizeZ (const domainSizeZ_type& x)
{
  this->domainSizeZ_.set (x);
}

const generalParams::useThermostat_type& generalParams::
useThermostat () const
{
  return this->useThermostat_.get ();
}

generalParams::useThermostat_type& generalParams::
useThermostat ()
{
  return this->useThermostat_.get ();
}

void generalParams::
useThermostat (const useThermostat_type& x)
{
  this->useThermostat_.set (x);
}

void generalParams::
useThermostat (::std::unique_ptr< useThermostat_type > x)
{
  this->useThermostat_.set (std::move (x));
}

const generalParams::thermostatType_type& generalParams::
thermostatType () const
{
  return this->thermostatType_.get ();
}

generalParams::thermostatType_type& generalParams::
thermostatType ()
{
  return this->thermostatType_.get ();
}

void generalParams::
thermostatType (const thermostatType_type& x)
{
  this->thermostatType_.set (x);
}

void generalParams::
thermostatType (::std::unique_ptr< thermostatType_type > x)
{
  this->thermostatType_.set (std::move (x));
}

const generalParams::useBrownianMotion_type& generalParams::
useBrownianMotion () const
{
  return this->useBrownianMotion_.get ();
}

generalParams::useBrownianMotion_type& generalParams::
useBrownianMotion ()
{
  return this->useBrownianMotion_.get ();
}

void generalParams::
useBrownianMotion (const useBrownianMotion_type& x)
{
  this->useBrownianMotion_.set (x);
}

void generalParams::
useBrownianMotion (::std::unique_ptr< useBrownianMotion_type > x)
{
  this->useBrownianMotion_.set (std::move (x));
}

const generalParams::T_init_type& generalParams::
T_init () const
{
  return this->T_init_.get ();
}

generalParams::T_init_type& generalParams::
T_init ()
{
  return this->T_init_.get ();
}

void generalParams::
T_init (const T_init_type& x)
{
  this->T_init_.set (x);
}

const generalParams::T_target_type& generalParams::
T_target () const
{
  return this->T_target_.get ();
}

generalParams::T_target_type& generalParams::
T_target ()
{
  return this->T_target_.get ();
}

void generalParams::
T_target (const T_target_type& x)
{
  this->T_target_.set (x);
}

const generalParams::delta_T_type& generalParams::
delta_T () const
{
  return this->delta_T_.get ();
}

generalParams::delta_T_type& generalParams::
delta_T ()
{
  return this->delta_T_.get ();
}

void generalParams::
delta_T (const delta_T_type& x)
{
  this->delta_T_.set (x);
}

const generalParams::n_thermostat_type& generalParams::
n_thermostat () const
{
  return this->n_thermostat_.get ();
}

generalParams::n_thermostat_type& generalParams::
n_thermostat ()
{
  return this->n_thermostat_.get ();
}

void generalParams::
n_thermostat (const n_thermostat_type& x)
{
  this->n_thermostat_.set (x);
}

const generalParams::useVelDensProfiling_type& generalParams::
useVelDensProfiling () const
{
  return this->useVelDensProfiling_.get ();
}

generalParams::useVelDensProfiling_type& generalParams::
useVelDensProfiling ()
{
  return this->useVelDensProfiling_.get ();
}

void generalParams::
useVelDensProfiling (const useVelDensProfiling_type& x)
{
  this->useVelDensProfiling_.set (x);
}

void generalParams::
useVelDensProfiling (::std::unique_ptr< useVelDensProfiling_type > x)
{
  this->useVelDensProfiling_.set (std::move (x));
}

const generalParams::numberOfBins_type& generalParams::
numberOfBins () const
{
  return this->numberOfBins_.get ();
}

generalParams::numberOfBins_type& generalParams::
numberOfBins ()
{
  return this->numberOfBins_.get ();
}

void generalParams::
numberOfBins (const numberOfBins_type& x)
{
  this->numberOfBins_.set (x);
}


// boundaryConditions
// 

const boundaryConditions::top_type& boundaryConditions::
top () const
{
  return this->top_.get ();
}

boundaryConditions::top_type& boundaryConditions::
top ()
{
  return this->top_.get ();
}

void boundaryConditions::
top (const top_type& x)
{
  this->top_.set (x);
}

void boundaryConditions::
top (::std::unique_ptr< top_type > x)
{
  this->top_.set (std::move (x));
}

const boundaryConditions::right_type& boundaryConditions::
right () const
{
  return this->right_.get ();
}

boundaryConditions::right_type& boundaryConditions::
right ()
{
  return this->right_.get ();
}

void boundaryConditions::
right (const right_type& x)
{
  this->right_.set (x);
}

void boundaryConditions::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}

const boundaryConditions::bottom_type& boundaryConditions::
bottom () const
{
  return this->bottom_.get ();
}

boundaryConditions::bottom_type& boundaryConditions::
bottom ()
{
  return this->bottom_.get ();
}

void boundaryConditions::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

void boundaryConditions::
bottom (::std::unique_ptr< bottom_type > x)
{
  this->bottom_.set (std::move (x));
}

const boundaryConditions::left_type& boundaryConditions::
left () const
{
  return this->left_.get ();
}

boundaryConditions::left_type& boundaryConditions::
left ()
{
  return this->left_.get ();
}

void boundaryConditions::
left (const left_type& x)
{
  this->left_.set (x);
}

void boundaryConditions::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const boundaryConditions::front_type& boundaryConditions::
front () const
{
  return this->front_.get ();
}

boundaryConditions::front_type& boundaryConditions::
front ()
{
  return this->front_.get ();
}

void boundaryConditions::
front (const front_type& x)
{
  this->front_.set (x);
}

void boundaryConditions::
front (::std::unique_ptr< front_type > x)
{
  this->front_.set (std::move (x));
}

const boundaryConditions::back_type& boundaryConditions::
back () const
{
  return this->back_.get ();
}

boundaryConditions::back_type& boundaryConditions::
back ()
{
  return this->back_.get ();
}

void boundaryConditions::
back (const back_type& x)
{
  this->back_.set (x);
}

void boundaryConditions::
back (::std::unique_ptr< back_type > x)
{
  this->back_.set (std::move (x));
}


// particlesLJ
// 

const particlesLJ::body_sequence& particlesLJ::
body () const
{
  return this->body_;
}

particlesLJ::body_sequence& particlesLJ::
body ()
{
  return this->body_;
}

void particlesLJ::
body (const body_sequence& s)
{
  this->body_ = s;
}


// input
// 

const input::generalParams_type& input::
generalParams () const
{
  return this->generalParams_.get ();
}

input::generalParams_type& input::
generalParams ()
{
  return this->generalParams_.get ();
}

void input::
generalParams (const generalParams_type& x)
{
  this->generalParams_.set (x);
}

void input::
generalParams (::std::unique_ptr< generalParams_type > x)
{
  this->generalParams_.set (std::move (x));
}

const input::boundaryConditions_type& input::
boundaryConditions () const
{
  return this->boundaryConditions_.get ();
}

input::boundaryConditions_type& input::
boundaryConditions ()
{
  return this->boundaryConditions_.get ();
}

void input::
boundaryConditions (const boundaryConditions_type& x)
{
  this->boundaryConditions_.set (x);
}

void input::
boundaryConditions (::std::unique_ptr< boundaryConditions_type > x)
{
  this->boundaryConditions_.set (std::move (x));
}

const input::particlesLJ_type& input::
particlesLJ () const
{
  return this->particlesLJ_.get ();
}

input::particlesLJ_type& input::
particlesLJ ()
{
  return this->particlesLJ_.get ();
}

void input::
particlesLJ (const particlesLJ_type& x)
{
  this->particlesLJ_.set (x);
}

void input::
particlesLJ (::std::unique_ptr< particlesLJ_type > x)
{
  this->particlesLJ_.set (std::move (x));
}


// body
// 

const body::bodyType_type& body::
bodyType () const
{
  return this->bodyType_.get ();
}

body::bodyType_type& body::
bodyType ()
{
  return this->bodyType_.get ();
}

void body::
bodyType (const bodyType_type& x)
{
  this->bodyType_.set (x);
}

void body::
bodyType (::std::unique_ptr< bodyType_type > x)
{
  this->bodyType_.set (std::move (x));
}

const body::position_type& body::
position () const
{
  return this->position_.get ();
}

body::position_type& body::
position ()
{
  return this->position_.get ();
}

void body::
position (const position_type& x)
{
  this->position_.set (x);
}

void body::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const body::velocity_type& body::
velocity () const
{
  return this->velocity_.get ();
}

body::velocity_type& body::
velocity ()
{
  return this->velocity_.get ();
}

void body::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void body::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const body::objectSpecificFormat_type& body::
objectSpecificFormat () const
{
  return this->objectSpecificFormat_.get ();
}

body::objectSpecificFormat_type& body::
objectSpecificFormat ()
{
  return this->objectSpecificFormat_.get ();
}

void body::
objectSpecificFormat (const objectSpecificFormat_type& x)
{
  this->objectSpecificFormat_.set (x);
}

void body::
objectSpecificFormat (::std::unique_ptr< objectSpecificFormat_type > x)
{
  this->objectSpecificFormat_.set (std::move (x));
}

const body::epsilon_type& body::
epsilon () const
{
  return this->epsilon_.get ();
}

body::epsilon_type& body::
epsilon ()
{
  return this->epsilon_.get ();
}

void body::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const body::mass_type& body::
mass () const
{
  return this->mass_.get ();
}

body::mass_type& body::
mass ()
{
  return this->mass_.get ();
}

void body::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const body::rho_type& body::
rho () const
{
  return this->rho_.get ();
}

body::rho_type& body::
rho ()
{
  return this->rho_.get ();
}

void body::
rho (const rho_type& x)
{
  this->rho_.set (x);
}

const body::h_type& body::
h () const
{
  return this->h_.get ();
}

body::h_type& body::
h ()
{
  return this->h_.get ();
}

void body::
h (const h_type& x)
{
  this->h_.set (x);
}

const body::bodyState_type& body::
bodyState () const
{
  return this->bodyState_.get ();
}

body::bodyState_type& body::
bodyState ()
{
  return this->bodyState_.get ();
}

void body::
bodyState (const bodyState_type& x)
{
  this->bodyState_.set (x);
}

void body::
bodyState (::std::unique_ptr< bodyState_type > x)
{
  this->bodyState_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// bodyType
//

bodyType::
bodyType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_bodyType_convert ();
}

bodyType::
bodyType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_bodyType_convert ();
}

bodyType::
bodyType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_bodyType_convert ();
}

bodyType* bodyType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class bodyType (*this, f, c);
}

bodyType::value bodyType::
_xsd_bodyType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bodyType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_bodyType_indexes_,
                    _xsd_bodyType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_bodyType_indexes_ + 4 || _xsd_bodyType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const bodyType::
_xsd_bodyType_literals_[4] =
{
  "Cuboid",
  "Tetrahedron",
  "Sphere",
  "Membrane"
};

const bodyType::value bodyType::
_xsd_bodyType_indexes_[4] =
{
  ::bodyType::Cuboid,
  ::bodyType::Membrane,
  ::bodyType::Sphere,
  ::bodyType::Tetrahedron
};

// calcType
//

calcType::
calcType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_calcType_convert ();
}

calcType::
calcType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_calcType_convert ();
}

calcType::
calcType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_calcType_convert ();
}

calcType* calcType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class calcType (*this, f, c);
}

calcType::value calcType::
_xsd_calcType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_calcType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_calcType_indexes_,
                    _xsd_calcType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_calcType_indexes_ + 2 || _xsd_calcType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const calcType::
_xsd_calcType_literals_[2] =
{
  "LJ",
  "G"
};

const calcType::value calcType::
_xsd_calcType_indexes_[2] =
{
  ::calcType::G,
  ::calcType::LJ
};

// particleContainerType
//

particleContainerType::
particleContainerType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_particleContainerType_convert ();
}

particleContainerType::
particleContainerType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_particleContainerType_convert ();
}

particleContainerType::
particleContainerType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_particleContainerType_convert ();
}

particleContainerType* particleContainerType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particleContainerType (*this, f, c);
}

particleContainerType::value particleContainerType::
_xsd_particleContainerType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_particleContainerType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_particleContainerType_indexes_,
                    _xsd_particleContainerType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_particleContainerType_indexes_ + 2 || _xsd_particleContainerType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const particleContainerType::
_xsd_particleContainerType_literals_[2] =
{
  "directSum",
  "linkedCell"
};

const particleContainerType::value particleContainerType::
_xsd_particleContainerType_indexes_[2] =
{
  ::particleContainerType::directSum,
  ::particleContainerType::linkedCell
};

// yesNo
//

yesNo::
yesNo (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_yesNo_convert ();
}

yesNo::
yesNo (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_yesNo_convert ();
}

yesNo::
yesNo (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_yesNo_convert ();
}

yesNo* yesNo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class yesNo (*this, f, c);
}

yesNo::value yesNo::
_xsd_yesNo_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_yesNo_literals_);
  const value* i (::std::lower_bound (
                    _xsd_yesNo_indexes_,
                    _xsd_yesNo_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_yesNo_indexes_ + 2 || _xsd_yesNo_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const yesNo::
_xsd_yesNo_literals_[2] =
{
  "yes",
  "no"
};

const yesNo::value yesNo::
_xsd_yesNo_indexes_[2] =
{
  ::yesNo::no,
  ::yesNo::yes
};

// parallelType
//

parallelType::
parallelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_parallelType_convert ();
}

parallelType::
parallelType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_parallelType_convert ();
}

parallelType::
parallelType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_parallelType_convert ();
}

parallelType* parallelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class parallelType (*this, f, c);
}

parallelType::value parallelType::
_xsd_parallelType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_parallelType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_parallelType_indexes_,
                    _xsd_parallelType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_parallelType_indexes_ + 3 || _xsd_parallelType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const parallelType::
_xsd_parallelType_literals_[3] =
{
  "notParallel",
  "first",
  "second"
};

const parallelType::value parallelType::
_xsd_parallelType_indexes_[3] =
{
  ::parallelType::first,
  ::parallelType::notParallel,
  ::parallelType::second
};

// boundaryCondition
//

boundaryCondition::
boundaryCondition (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_boundaryCondition_convert ();
}

boundaryCondition::
boundaryCondition (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_boundaryCondition_convert ();
}

boundaryCondition::
boundaryCondition (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_boundaryCondition_convert ();
}

boundaryCondition* boundaryCondition::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaryCondition (*this, f, c);
}

boundaryCondition::value boundaryCondition::
_xsd_boundaryCondition_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_boundaryCondition_literals_);
  const value* i (::std::lower_bound (
                    _xsd_boundaryCondition_indexes_,
                    _xsd_boundaryCondition_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_boundaryCondition_indexes_ + 4 || _xsd_boundaryCondition_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const boundaryCondition::
_xsd_boundaryCondition_literals_[4] =
{
  "outflowType",
  "reflectingType",
  "betterReflectingType",
  "periodicType"
};

const boundaryCondition::value boundaryCondition::
_xsd_boundaryCondition_indexes_[4] =
{
  ::boundaryCondition::betterReflectingType,
  ::boundaryCondition::outflowType,
  ::boundaryCondition::periodicType,
  ::boundaryCondition::reflectingType
};

// dimensionType
//

dimensionType::
dimensionType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_dimensionType_convert ();
}

dimensionType::
dimensionType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_dimensionType_convert ();
}

dimensionType::
dimensionType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_dimensionType_convert ();
}

dimensionType* dimensionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimensionType (*this, f, c);
}

dimensionType::value dimensionType::
_xsd_dimensionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_dimensionType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_dimensionType_indexes_,
                    _xsd_dimensionType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_dimensionType_indexes_ + 2 || _xsd_dimensionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const dimensionType::
_xsd_dimensionType_literals_[2] =
{
  "2D",
  "3D"
};

const dimensionType::value dimensionType::
_xsd_dimensionType_indexes_[2] =
{
  ::dimensionType::cxx_2D,
  ::dimensionType::cxx_3D
};

// bodyState
//

bodyState::
bodyState (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_bodyState_convert ();
}

bodyState::
bodyState (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_bodyState_convert ();
}

bodyState::
bodyState (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_bodyState_convert ();
}

bodyState* bodyState::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class bodyState (*this, f, c);
}

bodyState::value bodyState::
_xsd_bodyState_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_bodyState_literals_);
  const value* i (::std::lower_bound (
                    _xsd_bodyState_indexes_,
                    _xsd_bodyState_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_bodyState_indexes_ + 2 || _xsd_bodyState_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const bodyState::
_xsd_bodyState_literals_[2] =
{
  "fixed",
  "moving"
};

const bodyState::value bodyState::
_xsd_bodyState_indexes_[2] =
{
  ::bodyState::fixed,
  ::bodyState::moving
};

// thermostatType
//

thermostatType::
thermostatType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_thermostatType_convert ();
}

thermostatType::
thermostatType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_thermostatType_convert ();
}

thermostatType::
thermostatType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_thermostatType_convert ();
}

thermostatType* thermostatType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermostatType (*this, f, c);
}

thermostatType::value thermostatType::
_xsd_thermostatType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_thermostatType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_thermostatType_indexes_,
                    _xsd_thermostatType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_thermostatType_indexes_ + 2 || _xsd_thermostatType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const thermostatType::
_xsd_thermostatType_literals_[2] =
{
  "regular",
  "onlyFluid"
};

const thermostatType::value thermostatType::
_xsd_thermostatType_indexes_[2] =
{
  ::thermostatType::onlyFluid,
  ::thermostatType::regular
};

// gravDirectionType
//

gravDirectionType::
gravDirectionType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_gravDirectionType_convert ();
}

gravDirectionType::
gravDirectionType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_gravDirectionType_convert ();
}

gravDirectionType::
gravDirectionType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_gravDirectionType_convert ();
}

gravDirectionType* gravDirectionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravDirectionType (*this, f, c);
}

gravDirectionType::value gravDirectionType::
_xsd_gravDirectionType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_gravDirectionType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_gravDirectionType_indexes_,
                    _xsd_gravDirectionType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_gravDirectionType_indexes_ + 3 || _xsd_gravDirectionType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const gravDirectionType::
_xsd_gravDirectionType_literals_[3] =
{
  "x",
  "y",
  "z"
};

const gravDirectionType::value gravDirectionType::
_xsd_gravDirectionType_indexes_[3] =
{
  ::gravDirectionType::x,
  ::gravDirectionType::y,
  ::gravDirectionType::z
};

// generalParams
//

generalParams::
generalParams (const t_end_type& t_end,
               const delta_t_type& delta_t,
               const writeFrequency_type& writeFrequency,
               const dimensionType_type& dimensionType,
               const parallelType_type& parallelType,
               const g_grav_type& g_grav,
               const useGravity_type& useGravity,
               const gravDirection_type& gravDirection,
               const calcType_type& calcType,
               const baseNameOutputFiles_type& baseNameOutputFiles,
               const particleContainerType_type& particleContainerType,
               const cutoffRadius_type& cutoffRadius,
               const gravInput_type& gravInput,
               const loadCheckpoint_type& loadCheckpoint,
               const makeCheckpoint_type& makeCheckpoint,
               const pathInCheckpoint_type& pathInCheckpoint,
               const pathOutCheckpoint_type& pathOutCheckpoint,
               const domainSizeX_type& domainSizeX,
               const domainSizeY_type& domainSizeY,
               const domainSizeZ_type& domainSizeZ,
               const useThermostat_type& useThermostat,
               const thermostatType_type& thermostatType,
               const useBrownianMotion_type& useBrownianMotion,
               const T_init_type& T_init,
               const T_target_type& T_target,
               const delta_T_type& delta_T,
               const n_thermostat_type& n_thermostat,
               const useVelDensProfiling_type& useVelDensProfiling,
               const numberOfBins_type& numberOfBins)
: ::xml_schema::type (),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  writeFrequency_ (writeFrequency, this),
  dimensionType_ (dimensionType, this),
  parallelType_ (parallelType, this),
  g_grav_ (g_grav, this),
  useGravity_ (useGravity, this),
  gravDirection_ (gravDirection, this),
  calcType_ (calcType, this),
  baseNameOutputFiles_ (baseNameOutputFiles, this),
  particleContainerType_ (particleContainerType, this),
  cutoffRadius_ (cutoffRadius, this),
  gravInput_ (gravInput, this),
  loadCheckpoint_ (loadCheckpoint, this),
  makeCheckpoint_ (makeCheckpoint, this),
  pathInCheckpoint_ (pathInCheckpoint, this),
  pathOutCheckpoint_ (pathOutCheckpoint, this),
  domainSizeX_ (domainSizeX, this),
  domainSizeY_ (domainSizeY, this),
  domainSizeZ_ (domainSizeZ, this),
  useThermostat_ (useThermostat, this),
  thermostatType_ (thermostatType, this),
  useBrownianMotion_ (useBrownianMotion, this),
  T_init_ (T_init, this),
  T_target_ (T_target, this),
  delta_T_ (delta_T, this),
  n_thermostat_ (n_thermostat, this),
  useVelDensProfiling_ (useVelDensProfiling, this),
  numberOfBins_ (numberOfBins, this)
{
}

generalParams::
generalParams (const generalParams& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  t_end_ (x.t_end_, f, this),
  delta_t_ (x.delta_t_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this),
  dimensionType_ (x.dimensionType_, f, this),
  parallelType_ (x.parallelType_, f, this),
  g_grav_ (x.g_grav_, f, this),
  useGravity_ (x.useGravity_, f, this),
  gravDirection_ (x.gravDirection_, f, this),
  calcType_ (x.calcType_, f, this),
  baseNameOutputFiles_ (x.baseNameOutputFiles_, f, this),
  particleContainerType_ (x.particleContainerType_, f, this),
  cutoffRadius_ (x.cutoffRadius_, f, this),
  gravInput_ (x.gravInput_, f, this),
  loadCheckpoint_ (x.loadCheckpoint_, f, this),
  makeCheckpoint_ (x.makeCheckpoint_, f, this),
  pathInCheckpoint_ (x.pathInCheckpoint_, f, this),
  pathOutCheckpoint_ (x.pathOutCheckpoint_, f, this),
  domainSizeX_ (x.domainSizeX_, f, this),
  domainSizeY_ (x.domainSizeY_, f, this),
  domainSizeZ_ (x.domainSizeZ_, f, this),
  useThermostat_ (x.useThermostat_, f, this),
  thermostatType_ (x.thermostatType_, f, this),
  useBrownianMotion_ (x.useBrownianMotion_, f, this),
  T_init_ (x.T_init_, f, this),
  T_target_ (x.T_target_, f, this),
  delta_T_ (x.delta_T_, f, this),
  n_thermostat_ (x.n_thermostat_, f, this),
  useVelDensProfiling_ (x.useVelDensProfiling_, f, this),
  numberOfBins_ (x.numberOfBins_, f, this)
{
}

generalParams::
generalParams (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  t_end_ (this),
  delta_t_ (this),
  writeFrequency_ (this),
  dimensionType_ (this),
  parallelType_ (this),
  g_grav_ (this),
  useGravity_ (this),
  gravDirection_ (this),
  calcType_ (this),
  baseNameOutputFiles_ (this),
  particleContainerType_ (this),
  cutoffRadius_ (this),
  gravInput_ (this),
  loadCheckpoint_ (this),
  makeCheckpoint_ (this),
  pathInCheckpoint_ (this),
  pathOutCheckpoint_ (this),
  domainSizeX_ (this),
  domainSizeY_ (this),
  domainSizeZ_ (this),
  useThermostat_ (this),
  thermostatType_ (this),
  useBrownianMotion_ (this),
  T_init_ (this),
  T_target_ (this),
  delta_T_ (this),
  n_thermostat_ (this),
  useVelDensProfiling_ (this),
  numberOfBins_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void generalParams::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // t_end
    //
    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      if (!t_end_.present ())
      {
        this->t_end_.set (t_end_traits::create (i, f, this));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      if (!delta_t_.present ())
      {
        this->delta_t_.set (delta_t_traits::create (i, f, this));
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // dimensionType
    //
    if (n.name () == "dimensionType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimensionType_type > r (
        dimensionType_traits::create (i, f, this));

      if (!dimensionType_.present ())
      {
        this->dimensionType_.set (::std::move (r));
        continue;
      }
    }

    // parallelType
    //
    if (n.name () == "parallelType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< parallelType_type > r (
        parallelType_traits::create (i, f, this));

      if (!parallelType_.present ())
      {
        this->parallelType_.set (::std::move (r));
        continue;
      }
    }

    // g_grav
    //
    if (n.name () == "g_grav" && n.namespace_ ().empty ())
    {
      if (!g_grav_.present ())
      {
        this->g_grav_.set (g_grav_traits::create (i, f, this));
        continue;
      }
    }

    // useGravity
    //
    if (n.name () == "useGravity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< useGravity_type > r (
        useGravity_traits::create (i, f, this));

      if (!useGravity_.present ())
      {
        this->useGravity_.set (::std::move (r));
        continue;
      }
    }

    // gravDirection
    //
    if (n.name () == "gravDirection" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravDirection_type > r (
        gravDirection_traits::create (i, f, this));

      if (!gravDirection_.present ())
      {
        this->gravDirection_.set (::std::move (r));
        continue;
      }
    }

    // calcType
    //
    if (n.name () == "calcType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< calcType_type > r (
        calcType_traits::create (i, f, this));

      if (!calcType_.present ())
      {
        this->calcType_.set (::std::move (r));
        continue;
      }
    }

    // baseNameOutputFiles
    //
    if (n.name () == "baseNameOutputFiles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< baseNameOutputFiles_type > r (
        baseNameOutputFiles_traits::create (i, f, this));

      if (!baseNameOutputFiles_.present ())
      {
        this->baseNameOutputFiles_.set (::std::move (r));
        continue;
      }
    }

    // particleContainerType
    //
    if (n.name () == "particleContainerType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particleContainerType_type > r (
        particleContainerType_traits::create (i, f, this));

      if (!particleContainerType_.present ())
      {
        this->particleContainerType_.set (::std::move (r));
        continue;
      }
    }

    // cutoffRadius
    //
    if (n.name () == "cutoffRadius" && n.namespace_ ().empty ())
    {
      if (!cutoffRadius_.present ())
      {
        this->cutoffRadius_.set (cutoffRadius_traits::create (i, f, this));
        continue;
      }
    }

    // gravInput
    //
    if (n.name () == "gravInput" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravInput_type > r (
        gravInput_traits::create (i, f, this));

      if (!gravInput_.present ())
      {
        this->gravInput_.set (::std::move (r));
        continue;
      }
    }

    // loadCheckpoint
    //
    if (n.name () == "loadCheckpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< loadCheckpoint_type > r (
        loadCheckpoint_traits::create (i, f, this));

      if (!loadCheckpoint_.present ())
      {
        this->loadCheckpoint_.set (::std::move (r));
        continue;
      }
    }

    // makeCheckpoint
    //
    if (n.name () == "makeCheckpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< makeCheckpoint_type > r (
        makeCheckpoint_traits::create (i, f, this));

      if (!makeCheckpoint_.present ())
      {
        this->makeCheckpoint_.set (::std::move (r));
        continue;
      }
    }

    // pathInCheckpoint
    //
    if (n.name () == "pathInCheckpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< pathInCheckpoint_type > r (
        pathInCheckpoint_traits::create (i, f, this));

      if (!pathInCheckpoint_.present ())
      {
        this->pathInCheckpoint_.set (::std::move (r));
        continue;
      }
    }

    // pathOutCheckpoint
    //
    if (n.name () == "pathOutCheckpoint" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< pathOutCheckpoint_type > r (
        pathOutCheckpoint_traits::create (i, f, this));

      if (!pathOutCheckpoint_.present ())
      {
        this->pathOutCheckpoint_.set (::std::move (r));
        continue;
      }
    }

    // domainSizeX
    //
    if (n.name () == "domainSizeX" && n.namespace_ ().empty ())
    {
      if (!domainSizeX_.present ())
      {
        this->domainSizeX_.set (domainSizeX_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeY
    //
    if (n.name () == "domainSizeY" && n.namespace_ ().empty ())
    {
      if (!domainSizeY_.present ())
      {
        this->domainSizeY_.set (domainSizeY_traits::create (i, f, this));
        continue;
      }
    }

    // domainSizeZ
    //
    if (n.name () == "domainSizeZ" && n.namespace_ ().empty ())
    {
      if (!domainSizeZ_.present ())
      {
        this->domainSizeZ_.set (domainSizeZ_traits::create (i, f, this));
        continue;
      }
    }

    // useThermostat
    //
    if (n.name () == "useThermostat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< useThermostat_type > r (
        useThermostat_traits::create (i, f, this));

      if (!useThermostat_.present ())
      {
        this->useThermostat_.set (::std::move (r));
        continue;
      }
    }

    // thermostatType
    //
    if (n.name () == "thermostatType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< thermostatType_type > r (
        thermostatType_traits::create (i, f, this));

      if (!thermostatType_.present ())
      {
        this->thermostatType_.set (::std::move (r));
        continue;
      }
    }

    // useBrownianMotion
    //
    if (n.name () == "useBrownianMotion" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< useBrownianMotion_type > r (
        useBrownianMotion_traits::create (i, f, this));

      if (!useBrownianMotion_.present ())
      {
        this->useBrownianMotion_.set (::std::move (r));
        continue;
      }
    }

    // T_init
    //
    if (n.name () == "T_init" && n.namespace_ ().empty ())
    {
      if (!T_init_.present ())
      {
        this->T_init_.set (T_init_traits::create (i, f, this));
        continue;
      }
    }

    // T_target
    //
    if (n.name () == "T_target" && n.namespace_ ().empty ())
    {
      if (!T_target_.present ())
      {
        this->T_target_.set (T_target_traits::create (i, f, this));
        continue;
      }
    }

    // delta_T
    //
    if (n.name () == "delta_T" && n.namespace_ ().empty ())
    {
      if (!delta_T_.present ())
      {
        this->delta_T_.set (delta_T_traits::create (i, f, this));
        continue;
      }
    }

    // n_thermostat
    //
    if (n.name () == "n_thermostat" && n.namespace_ ().empty ())
    {
      if (!n_thermostat_.present ())
      {
        this->n_thermostat_.set (n_thermostat_traits::create (i, f, this));
        continue;
      }
    }

    // useVelDensProfiling
    //
    if (n.name () == "useVelDensProfiling" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< useVelDensProfiling_type > r (
        useVelDensProfiling_traits::create (i, f, this));

      if (!useVelDensProfiling_.present ())
      {
        this->useVelDensProfiling_.set (::std::move (r));
        continue;
      }
    }

    // numberOfBins
    //
    if (n.name () == "numberOfBins" && n.namespace_ ().empty ())
    {
      if (!numberOfBins_.present ())
      {
        this->numberOfBins_.set (numberOfBins_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "t_end",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_t",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }

  if (!dimensionType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensionType",
      "");
  }

  if (!parallelType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "parallelType",
      "");
  }

  if (!g_grav_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "g_grav",
      "");
  }

  if (!useGravity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "useGravity",
      "");
  }

  if (!gravDirection_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "gravDirection",
      "");
  }

  if (!calcType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calcType",
      "");
  }

  if (!baseNameOutputFiles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseNameOutputFiles",
      "");
  }

  if (!particleContainerType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particleContainerType",
      "");
  }

  if (!cutoffRadius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoffRadius",
      "");
  }

  if (!gravInput_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "gravInput",
      "");
  }

  if (!loadCheckpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "loadCheckpoint",
      "");
  }

  if (!makeCheckpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "makeCheckpoint",
      "");
  }

  if (!pathInCheckpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pathInCheckpoint",
      "");
  }

  if (!pathOutCheckpoint_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pathOutCheckpoint",
      "");
  }

  if (!domainSizeX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainSizeX",
      "");
  }

  if (!domainSizeY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainSizeY",
      "");
  }

  if (!domainSizeZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domainSizeZ",
      "");
  }

  if (!useThermostat_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "useThermostat",
      "");
  }

  if (!thermostatType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "thermostatType",
      "");
  }

  if (!useBrownianMotion_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "useBrownianMotion",
      "");
  }

  if (!T_init_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "T_init",
      "");
  }

  if (!T_target_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "T_target",
      "");
  }

  if (!delta_T_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_T",
      "");
  }

  if (!n_thermostat_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n_thermostat",
      "");
  }

  if (!useVelDensProfiling_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "useVelDensProfiling",
      "");
  }

  if (!numberOfBins_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "numberOfBins",
      "");
  }
}

generalParams* generalParams::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class generalParams (*this, f, c);
}

generalParams& generalParams::
operator= (const generalParams& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->t_end_ = x.t_end_;
    this->delta_t_ = x.delta_t_;
    this->writeFrequency_ = x.writeFrequency_;
    this->dimensionType_ = x.dimensionType_;
    this->parallelType_ = x.parallelType_;
    this->g_grav_ = x.g_grav_;
    this->useGravity_ = x.useGravity_;
    this->gravDirection_ = x.gravDirection_;
    this->calcType_ = x.calcType_;
    this->baseNameOutputFiles_ = x.baseNameOutputFiles_;
    this->particleContainerType_ = x.particleContainerType_;
    this->cutoffRadius_ = x.cutoffRadius_;
    this->gravInput_ = x.gravInput_;
    this->loadCheckpoint_ = x.loadCheckpoint_;
    this->makeCheckpoint_ = x.makeCheckpoint_;
    this->pathInCheckpoint_ = x.pathInCheckpoint_;
    this->pathOutCheckpoint_ = x.pathOutCheckpoint_;
    this->domainSizeX_ = x.domainSizeX_;
    this->domainSizeY_ = x.domainSizeY_;
    this->domainSizeZ_ = x.domainSizeZ_;
    this->useThermostat_ = x.useThermostat_;
    this->thermostatType_ = x.thermostatType_;
    this->useBrownianMotion_ = x.useBrownianMotion_;
    this->T_init_ = x.T_init_;
    this->T_target_ = x.T_target_;
    this->delta_T_ = x.delta_T_;
    this->n_thermostat_ = x.n_thermostat_;
    this->useVelDensProfiling_ = x.useVelDensProfiling_;
    this->numberOfBins_ = x.numberOfBins_;
  }

  return *this;
}

generalParams::
~generalParams ()
{
}

// boundaryConditions
//

boundaryConditions::
boundaryConditions (const top_type& top,
                    const right_type& right,
                    const bottom_type& bottom,
                    const left_type& left,
                    const front_type& front,
                    const back_type& back)
: ::xml_schema::type (),
  top_ (top, this),
  right_ (right, this),
  bottom_ (bottom, this),
  left_ (left, this),
  front_ (front, this),
  back_ (back, this)
{
}

boundaryConditions::
boundaryConditions (const boundaryConditions& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  top_ (x.top_, f, this),
  right_ (x.right_, f, this),
  bottom_ (x.bottom_, f, this),
  left_ (x.left_, f, this),
  front_ (x.front_, f, this),
  back_ (x.back_, f, this)
{
}

boundaryConditions::
boundaryConditions (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  top_ (this),
  right_ (this),
  bottom_ (this),
  left_ (this),
  front_ (this),
  back_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundaryConditions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // top
    //
    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< top_type > r (
        top_traits::create (i, f, this));

      if (!top_.present ())
      {
        this->top_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!right_.present ())
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< bottom_type > r (
        bottom_traits::create (i, f, this));

      if (!bottom_.present ())
      {
        this->bottom_.set (::std::move (r));
        continue;
      }
    }

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!left_.present ())
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< front_type > r (
        front_traits::create (i, f, this));

      if (!front_.present ())
      {
        this->front_.set (::std::move (r));
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< back_type > r (
        back_traits::create (i, f, this));

      if (!back_.present ())
      {
        this->back_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "top",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!front_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "front",
      "");
  }

  if (!back_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "back",
      "");
  }
}

boundaryConditions* boundaryConditions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaryConditions (*this, f, c);
}

boundaryConditions& boundaryConditions::
operator= (const boundaryConditions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->top_ = x.top_;
    this->right_ = x.right_;
    this->bottom_ = x.bottom_;
    this->left_ = x.left_;
    this->front_ = x.front_;
    this->back_ = x.back_;
  }

  return *this;
}

boundaryConditions::
~boundaryConditions ()
{
}

// particlesLJ
//

particlesLJ::
particlesLJ ()
: ::xml_schema::type (),
  body_ (this)
{
}

particlesLJ::
particlesLJ (const particlesLJ& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  body_ (x.body_, f, this)
{
}

particlesLJ::
particlesLJ (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  body_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particlesLJ::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // body
    //
    if (n.name () == "body" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< body_type > r (
        body_traits::create (i, f, this));

      this->body_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particlesLJ* particlesLJ::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particlesLJ (*this, f, c);
}

particlesLJ& particlesLJ::
operator= (const particlesLJ& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->body_ = x.body_;
  }

  return *this;
}

particlesLJ::
~particlesLJ ()
{
}

// input
//

input::
input (const generalParams_type& generalParams,
       const boundaryConditions_type& boundaryConditions,
       const particlesLJ_type& particlesLJ)
: ::xml_schema::type (),
  generalParams_ (generalParams, this),
  boundaryConditions_ (boundaryConditions, this),
  particlesLJ_ (particlesLJ, this)
{
}

input::
input (::std::unique_ptr< generalParams_type > generalParams,
       ::std::unique_ptr< boundaryConditions_type > boundaryConditions,
       ::std::unique_ptr< particlesLJ_type > particlesLJ)
: ::xml_schema::type (),
  generalParams_ (std::move (generalParams), this),
  boundaryConditions_ (std::move (boundaryConditions), this),
  particlesLJ_ (std::move (particlesLJ), this)
{
}

input::
input (const input& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  generalParams_ (x.generalParams_, f, this),
  boundaryConditions_ (x.boundaryConditions_, f, this),
  particlesLJ_ (x.particlesLJ_, f, this)
{
}

input::
input (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  generalParams_ (this),
  boundaryConditions_ (this),
  particlesLJ_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void input::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // generalParams
    //
    if (n.name () == "generalParams" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< generalParams_type > r (
        generalParams_traits::create (i, f, this));

      if (!generalParams_.present ())
      {
        this->generalParams_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditions
    //
    if (n.name () == "boundaryConditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditions_type > r (
        boundaryConditions_traits::create (i, f, this));

      if (!boundaryConditions_.present ())
      {
        this->boundaryConditions_.set (::std::move (r));
        continue;
      }
    }

    // particlesLJ
    //
    if (n.name () == "particlesLJ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particlesLJ_type > r (
        particlesLJ_traits::create (i, f, this));

      if (!particlesLJ_.present ())
      {
        this->particlesLJ_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!generalParams_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "generalParams",
      "");
  }

  if (!boundaryConditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditions",
      "");
  }

  if (!particlesLJ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particlesLJ",
      "");
  }
}

input* input::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class input (*this, f, c);
}

input& input::
operator= (const input& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->generalParams_ = x.generalParams_;
    this->boundaryConditions_ = x.boundaryConditions_;
    this->particlesLJ_ = x.particlesLJ_;
  }

  return *this;
}

input::
~input ()
{
}

// body
//

body::
body (const bodyType_type& bodyType,
      const position_type& position,
      const velocity_type& velocity,
      const objectSpecificFormat_type& objectSpecificFormat,
      const epsilon_type& epsilon,
      const mass_type& mass,
      const rho_type& rho,
      const h_type& h,
      const bodyState_type& bodyState)
: ::xml_schema::type (),
  bodyType_ (bodyType, this),
  position_ (position, this),
  velocity_ (velocity, this),
  objectSpecificFormat_ (objectSpecificFormat, this),
  epsilon_ (epsilon, this),
  mass_ (mass, this),
  rho_ (rho, this),
  h_ (h, this),
  bodyState_ (bodyState, this)
{
}

body::
body (const body& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  bodyType_ (x.bodyType_, f, this),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  objectSpecificFormat_ (x.objectSpecificFormat_, f, this),
  epsilon_ (x.epsilon_, f, this),
  mass_ (x.mass_, f, this),
  rho_ (x.rho_, f, this),
  h_ (x.h_, f, this),
  bodyState_ (x.bodyState_, f, this)
{
}

body::
body (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  bodyType_ (this),
  position_ (this),
  velocity_ (this),
  objectSpecificFormat_ (this),
  epsilon_ (this),
  mass_ (this),
  rho_ (this),
  h_ (this),
  bodyState_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // bodyType
    //
    if (n.name () == "bodyType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< bodyType_type > r (
        bodyType_traits::create (i, f, this));

      if (!bodyType_.present ())
      {
        this->bodyType_.set (::std::move (r));
        continue;
      }
    }

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // objectSpecificFormat
    //
    if (n.name () == "objectSpecificFormat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< objectSpecificFormat_type > r (
        objectSpecificFormat_traits::create (i, f, this));

      if (!objectSpecificFormat_.present ())
      {
        this->objectSpecificFormat_.set (::std::move (r));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // rho
    //
    if (n.name () == "rho" && n.namespace_ ().empty ())
    {
      if (!rho_.present ())
      {
        this->rho_.set (rho_traits::create (i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      if (!h_.present ())
      {
        this->h_.set (h_traits::create (i, f, this));
        continue;
      }
    }

    // bodyState
    //
    if (n.name () == "bodyState" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< bodyState_type > r (
        bodyState_traits::create (i, f, this));

      if (!bodyState_.present ())
      {
        this->bodyState_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!bodyType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bodyType",
      "");
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!objectSpecificFormat_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "objectSpecificFormat",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!rho_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rho",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }

  if (!bodyState_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bodyState",
      "");
  }
}

body* body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class body (*this, f, c);
}

body& body::
operator= (const body& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->bodyType_ = x.bodyType_;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->objectSpecificFormat_ = x.objectSpecificFormat_;
    this->epsilon_ = x.epsilon_;
    this->mass_ = x.mass_;
    this->rho_ = x.rho_;
    this->h_ = x.h_;
    this->bodyState_ = x.bodyState_;
  }

  return *this;
}

body::
~body ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::input >
input_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input_ (isrc, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input_ (isrc, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::input > (
      ::input_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "input" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::input > r (
      ::xsd::cxx::tree::traits< ::input, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "input",
    "");
}

::std::unique_ptr< ::input >
input_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "input" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::input > r (
      ::xsd::cxx::tree::traits< ::input, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "input",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

