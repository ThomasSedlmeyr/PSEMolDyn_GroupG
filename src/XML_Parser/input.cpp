// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "input.h"

// calcType
// 

calcType::
calcType (value v)
: ::xml_schema::string (_xsd_calcType_literals_[v])
{
}

calcType::
calcType (const char* v)
: ::xml_schema::string (v)
{
}

calcType::
calcType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

calcType::
calcType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

calcType::
calcType (const calcType& v,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

calcType& calcType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_calcType_literals_[v]);

  return *this;
}


// paramsLJ
// 

const paramsLJ::epsilon_type& paramsLJ::
epsilon () const
{
  return this->epsilon_.get ();
}

paramsLJ::epsilon_type& paramsLJ::
epsilon ()
{
  return this->epsilon_.get ();
}

void paramsLJ::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const paramsLJ::mass_type& paramsLJ::
mass () const
{
  return this->mass_.get ();
}

paramsLJ::mass_type& paramsLJ::
mass ()
{
  return this->mass_.get ();
}

void paramsLJ::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const paramsLJ::rho_type& paramsLJ::
rho () const
{
  return this->rho_.get ();
}

paramsLJ::rho_type& paramsLJ::
rho ()
{
  return this->rho_.get ();
}

void paramsLJ::
rho (const rho_type& x)
{
  this->rho_.set (x);
}

const paramsLJ::h_type& paramsLJ::
h () const
{
  return this->h_.get ();
}

paramsLJ::h_type& paramsLJ::
h ()
{
  return this->h_.get ();
}

void paramsLJ::
h (const h_type& x)
{
  this->h_.set (x);
}


// boundaryConditions
// 

const boundaryConditions::top_type& boundaryConditions::
top () const
{
  return this->top_.get ();
}

boundaryConditions::top_type& boundaryConditions::
top ()
{
  return this->top_.get ();
}

void boundaryConditions::
top (const top_type& x)
{
  this->top_.set (x);
}

const boundaryConditions::right_type& boundaryConditions::
right () const
{
  return this->right_.get ();
}

boundaryConditions::right_type& boundaryConditions::
right ()
{
  return this->right_.get ();
}

void boundaryConditions::
right (const right_type& x)
{
  this->right_.set (x);
}

const boundaryConditions::bottom_type& boundaryConditions::
bottom () const
{
  return this->bottom_.get ();
}

boundaryConditions::bottom_type& boundaryConditions::
bottom ()
{
  return this->bottom_.get ();
}

void boundaryConditions::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

const boundaryConditions::left_type& boundaryConditions::
left () const
{
  return this->left_.get ();
}

boundaryConditions::left_type& boundaryConditions::
left ()
{
  return this->left_.get ();
}

void boundaryConditions::
left (const left_type& x)
{
  this->left_.set (x);
}

const boundaryConditions::front_type& boundaryConditions::
front () const
{
  return this->front_.get ();
}

boundaryConditions::front_type& boundaryConditions::
front ()
{
  return this->front_.get ();
}

void boundaryConditions::
front (const front_type& x)
{
  this->front_.set (x);
}

const boundaryConditions::back_type& boundaryConditions::
back () const
{
  return this->back_.get ();
}

boundaryConditions::back_type& boundaryConditions::
back ()
{
  return this->back_.get ();
}

void boundaryConditions::
back (const back_type& x)
{
  this->back_.set (x);
}


// particlesLJ
// 

const particlesLJ::body_sequence& particlesLJ::
body () const
{
  return this->body_;
}

particlesLJ::body_sequence& particlesLJ::
body ()
{
  return this->body_;
}

void particlesLJ::
body (const body_sequence& s)
{
  this->body_ = s;
}


// input
// 

const input::t_end_type& input::
t_end () const
{
  return this->t_end_.get ();
}

input::t_end_type& input::
t_end ()
{
  return this->t_end_.get ();
}

void input::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const input::delta_t_type& input::
delta_t () const
{
  return this->delta_t_.get ();
}

input::delta_t_type& input::
delta_t ()
{
  return this->delta_t_.get ();
}

void input::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const input::calcType_type& input::
calcType () const
{
  return this->calcType_.get ();
}

input::calcType_type& input::
calcType ()
{
  return this->calcType_.get ();
}

void input::
calcType (const calcType_type& x)
{
  this->calcType_.set (x);
}

void input::
calcType (::std::unique_ptr< calcType_type > x)
{
  this->calcType_.set (std::move (x));
}

const input::baseNameOutputFiles_type& input::
baseNameOutputFiles () const
{
  return this->baseNameOutputFiles_.get ();
}

input::baseNameOutputFiles_type& input::
baseNameOutputFiles ()
{
  return this->baseNameOutputFiles_.get ();
}

void input::
baseNameOutputFiles (const baseNameOutputFiles_type& x)
{
  this->baseNameOutputFiles_.set (x);
}

void input::
baseNameOutputFiles (::std::unique_ptr< baseNameOutputFiles_type > x)
{
  this->baseNameOutputFiles_.set (std::move (x));
}

const input::writeFrequency_type& input::
writeFrequency () const
{
  return this->writeFrequency_.get ();
}

input::writeFrequency_type& input::
writeFrequency ()
{
  return this->writeFrequency_.get ();
}

void input::
writeFrequency (const writeFrequency_type& x)
{
  this->writeFrequency_.set (x);
}

const input::gravInput_type& input::
gravInput () const
{
  return this->gravInput_.get ();
}

input::gravInput_type& input::
gravInput ()
{
  return this->gravInput_.get ();
}

void input::
gravInput (const gravInput_type& x)
{
  this->gravInput_.set (x);
}

void input::
gravInput (::std::unique_ptr< gravInput_type > x)
{
  this->gravInput_.set (std::move (x));
}

const input::paramsLJ_type& input::
paramsLJ () const
{
  return this->paramsLJ_.get ();
}

input::paramsLJ_type& input::
paramsLJ ()
{
  return this->paramsLJ_.get ();
}

void input::
paramsLJ (const paramsLJ_type& x)
{
  this->paramsLJ_.set (x);
}

void input::
paramsLJ (::std::unique_ptr< paramsLJ_type > x)
{
  this->paramsLJ_.set (std::move (x));
}

const input::boundaryConditions_type& input::
boundaryConditions () const
{
  return this->boundaryConditions_.get ();
}

input::boundaryConditions_type& input::
boundaryConditions ()
{
  return this->boundaryConditions_.get ();
}

void input::
boundaryConditions (const boundaryConditions_type& x)
{
  this->boundaryConditions_.set (x);
}

void input::
boundaryConditions (::std::unique_ptr< boundaryConditions_type > x)
{
  this->boundaryConditions_.set (std::move (x));
}

const input::particlesLJ_type& input::
particlesLJ () const
{
  return this->particlesLJ_.get ();
}

input::particlesLJ_type& input::
particlesLJ ()
{
  return this->particlesLJ_.get ();
}

void input::
particlesLJ (const particlesLJ_type& x)
{
  this->particlesLJ_.set (x);
}

void input::
particlesLJ (::std::unique_ptr< particlesLJ_type > x)
{
  this->particlesLJ_.set (std::move (x));
}


// body
// 

const body::bodyType_type& body::
bodyType () const
{
  return this->bodyType_.get ();
}

body::bodyType_type& body::
bodyType ()
{
  return this->bodyType_.get ();
}

void body::
bodyType (const bodyType_type& x)
{
  this->bodyType_.set (x);
}

void body::
bodyType (::std::unique_ptr< bodyType_type > x)
{
  this->bodyType_.set (std::move (x));
}

const body::position_type& body::
position () const
{
  return this->position_.get ();
}

body::position_type& body::
position ()
{
  return this->position_.get ();
}

void body::
position (const position_type& x)
{
  this->position_.set (x);
}

void body::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const body::velocity_type& body::
velocity () const
{
  return this->velocity_.get ();
}

body::velocity_type& body::
velocity ()
{
  return this->velocity_.get ();
}

void body::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void body::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const body::objectSpecificFormat_type& body::
objectSpecificFormat () const
{
  return this->objectSpecificFormat_.get ();
}

body::objectSpecificFormat_type& body::
objectSpecificFormat ()
{
  return this->objectSpecificFormat_.get ();
}

void body::
objectSpecificFormat (const objectSpecificFormat_type& x)
{
  this->objectSpecificFormat_.set (x);
}

void body::
objectSpecificFormat (::std::unique_ptr< objectSpecificFormat_type > x)
{
  this->objectSpecificFormat_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// calcType
//

calcType::
calcType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_calcType_convert ();
}

calcType::
calcType (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_calcType_convert ();
}

calcType::
calcType (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_calcType_convert ();
}

calcType* calcType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class calcType (*this, f, c);
}

calcType::value calcType::
_xsd_calcType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_calcType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_calcType_indexes_,
                    _xsd_calcType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_calcType_indexes_ + 2 || _xsd_calcType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const calcType::
_xsd_calcType_literals_[2] =
{
  "LJ",
  "G"
};

const calcType::value calcType::
_xsd_calcType_indexes_[2] =
{
  ::calcType::G,
  ::calcType::LJ
};

// paramsLJ
//

paramsLJ::
paramsLJ (const epsilon_type& epsilon,
          const mass_type& mass,
          const rho_type& rho,
          const h_type& h)
: ::xml_schema::type (),
  epsilon_ (epsilon, this),
  mass_ (mass, this),
  rho_ (rho, this),
  h_ (h, this)
{
}

paramsLJ::
paramsLJ (const paramsLJ& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  epsilon_ (x.epsilon_, f, this),
  mass_ (x.mass_, f, this),
  rho_ (x.rho_, f, this),
  h_ (x.h_, f, this)
{
}

paramsLJ::
paramsLJ (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  epsilon_ (this),
  mass_ (this),
  rho_ (this),
  h_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void paramsLJ::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // rho
    //
    if (n.name () == "rho" && n.namespace_ ().empty ())
    {
      if (!rho_.present ())
      {
        this->rho_.set (rho_traits::create (i, f, this));
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      if (!h_.present ())
      {
        this->h_.set (h_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!rho_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "rho",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }
}

paramsLJ* paramsLJ::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class paramsLJ (*this, f, c);
}

paramsLJ& paramsLJ::
operator= (const paramsLJ& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->epsilon_ = x.epsilon_;
    this->mass_ = x.mass_;
    this->rho_ = x.rho_;
    this->h_ = x.h_;
  }

  return *this;
}

paramsLJ::
~paramsLJ ()
{
}

// boundaryConditions
//

boundaryConditions::
boundaryConditions (const top_type& top,
                    const right_type& right,
                    const bottom_type& bottom,
                    const left_type& left,
                    const front_type& front,
                    const back_type& back)
: ::xml_schema::type (),
  top_ (top, this),
  right_ (right, this),
  bottom_ (bottom, this),
  left_ (left, this),
  front_ (front, this),
  back_ (back, this)
{
}

boundaryConditions::
boundaryConditions (const boundaryConditions& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  top_ (x.top_, f, this),
  right_ (x.right_, f, this),
  bottom_ (x.bottom_, f, this),
  left_ (x.left_, f, this),
  front_ (x.front_, f, this),
  back_ (x.back_, f, this)
{
}

boundaryConditions::
boundaryConditions (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  top_ (this),
  right_ (this),
  bottom_ (this),
  left_ (this),
  front_ (this),
  back_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundaryConditions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // top
    //
    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      if (!top_.present ())
      {
        this->top_.set (top_traits::create (i, f, this));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      if (!right_.present ())
      {
        this->right_.set (right_traits::create (i, f, this));
        continue;
      }
    }

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      if (!bottom_.present ())
      {
        this->bottom_.set (bottom_traits::create (i, f, this));
        continue;
      }
    }

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      if (!left_.present ())
      {
        this->left_.set (left_traits::create (i, f, this));
        continue;
      }
    }

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      if (!front_.present ())
      {
        this->front_.set (front_traits::create (i, f, this));
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      if (!back_.present ())
      {
        this->back_.set (back_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "top",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!front_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "front",
      "");
  }

  if (!back_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "back",
      "");
  }
}

boundaryConditions* boundaryConditions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaryConditions (*this, f, c);
}

boundaryConditions& boundaryConditions::
operator= (const boundaryConditions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->top_ = x.top_;
    this->right_ = x.right_;
    this->bottom_ = x.bottom_;
    this->left_ = x.left_;
    this->front_ = x.front_;
    this->back_ = x.back_;
  }

  return *this;
}

boundaryConditions::
~boundaryConditions ()
{
}

// particlesLJ
//

particlesLJ::
particlesLJ ()
: ::xml_schema::type (),
  body_ (this)
{
}

particlesLJ::
particlesLJ (const particlesLJ& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  body_ (x.body_, f, this)
{
}

particlesLJ::
particlesLJ (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  body_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particlesLJ::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // body
    //
    if (n.name () == "body" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< body_type > r (
        body_traits::create (i, f, this));

      this->body_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particlesLJ* particlesLJ::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particlesLJ (*this, f, c);
}

particlesLJ& particlesLJ::
operator= (const particlesLJ& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->body_ = x.body_;
  }

  return *this;
}

particlesLJ::
~particlesLJ ()
{
}

// input
//

input::
input (const t_end_type& t_end,
       const delta_t_type& delta_t,
       const calcType_type& calcType,
       const baseNameOutputFiles_type& baseNameOutputFiles,
       const writeFrequency_type& writeFrequency,
       const gravInput_type& gravInput,
       const paramsLJ_type& paramsLJ,
       const boundaryConditions_type& boundaryConditions,
       const particlesLJ_type& particlesLJ)
: ::xml_schema::type (),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  calcType_ (calcType, this),
  baseNameOutputFiles_ (baseNameOutputFiles, this),
  writeFrequency_ (writeFrequency, this),
  gravInput_ (gravInput, this),
  paramsLJ_ (paramsLJ, this),
  boundaryConditions_ (boundaryConditions, this),
  particlesLJ_ (particlesLJ, this)
{
}

input::
input (const t_end_type& t_end,
       const delta_t_type& delta_t,
       const calcType_type& calcType,
       const baseNameOutputFiles_type& baseNameOutputFiles,
       const writeFrequency_type& writeFrequency,
       const gravInput_type& gravInput,
       ::std::unique_ptr< paramsLJ_type > paramsLJ,
       ::std::unique_ptr< boundaryConditions_type > boundaryConditions,
       ::std::unique_ptr< particlesLJ_type > particlesLJ)
: ::xml_schema::type (),
  t_end_ (t_end, this),
  delta_t_ (delta_t, this),
  calcType_ (calcType, this),
  baseNameOutputFiles_ (baseNameOutputFiles, this),
  writeFrequency_ (writeFrequency, this),
  gravInput_ (gravInput, this),
  paramsLJ_ (std::move (paramsLJ), this),
  boundaryConditions_ (std::move (boundaryConditions), this),
  particlesLJ_ (std::move (particlesLJ), this)
{
}

input::
input (const input& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  t_end_ (x.t_end_, f, this),
  delta_t_ (x.delta_t_, f, this),
  calcType_ (x.calcType_, f, this),
  baseNameOutputFiles_ (x.baseNameOutputFiles_, f, this),
  writeFrequency_ (x.writeFrequency_, f, this),
  gravInput_ (x.gravInput_, f, this),
  paramsLJ_ (x.paramsLJ_, f, this),
  boundaryConditions_ (x.boundaryConditions_, f, this),
  particlesLJ_ (x.particlesLJ_, f, this)
{
}

input::
input (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  t_end_ (this),
  delta_t_ (this),
  calcType_ (this),
  baseNameOutputFiles_ (this),
  writeFrequency_ (this),
  gravInput_ (this),
  paramsLJ_ (this),
  boundaryConditions_ (this),
  particlesLJ_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void input::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // t_end
    //
    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      if (!t_end_.present ())
      {
        this->t_end_.set (t_end_traits::create (i, f, this));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      if (!delta_t_.present ())
      {
        this->delta_t_.set (delta_t_traits::create (i, f, this));
        continue;
      }
    }

    // calcType
    //
    if (n.name () == "calcType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< calcType_type > r (
        calcType_traits::create (i, f, this));

      if (!calcType_.present ())
      {
        this->calcType_.set (::std::move (r));
        continue;
      }
    }

    // baseNameOutputFiles
    //
    if (n.name () == "baseNameOutputFiles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< baseNameOutputFiles_type > r (
        baseNameOutputFiles_traits::create (i, f, this));

      if (!baseNameOutputFiles_.present ())
      {
        this->baseNameOutputFiles_.set (::std::move (r));
        continue;
      }
    }

    // writeFrequency
    //
    if (n.name () == "writeFrequency" && n.namespace_ ().empty ())
    {
      if (!writeFrequency_.present ())
      {
        this->writeFrequency_.set (writeFrequency_traits::create (i, f, this));
        continue;
      }
    }

    // gravInput
    //
    if (n.name () == "gravInput" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< gravInput_type > r (
        gravInput_traits::create (i, f, this));

      if (!gravInput_.present ())
      {
        this->gravInput_.set (::std::move (r));
        continue;
      }
    }

    // paramsLJ
    //
    if (n.name () == "paramsLJ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< paramsLJ_type > r (
        paramsLJ_traits::create (i, f, this));

      if (!paramsLJ_.present ())
      {
        this->paramsLJ_.set (::std::move (r));
        continue;
      }
    }

    // boundaryConditions
    //
    if (n.name () == "boundaryConditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundaryConditions_type > r (
        boundaryConditions_traits::create (i, f, this));

      if (!boundaryConditions_.present ())
      {
        this->boundaryConditions_.set (::std::move (r));
        continue;
      }
    }

    // particlesLJ
    //
    if (n.name () == "particlesLJ" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particlesLJ_type > r (
        particlesLJ_traits::create (i, f, this));

      if (!particlesLJ_.present ())
      {
        this->particlesLJ_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "t_end",
      "");
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_t",
      "");
  }

  if (!calcType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "calcType",
      "");
  }

  if (!baseNameOutputFiles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "baseNameOutputFiles",
      "");
  }

  if (!writeFrequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "writeFrequency",
      "");
  }

  if (!gravInput_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "gravInput",
      "");
  }

  if (!paramsLJ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "paramsLJ",
      "");
  }

  if (!boundaryConditions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundaryConditions",
      "");
  }

  if (!particlesLJ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particlesLJ",
      "");
  }
}

input* input::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class input (*this, f, c);
}

input& input::
operator= (const input& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->t_end_ = x.t_end_;
    this->delta_t_ = x.delta_t_;
    this->calcType_ = x.calcType_;
    this->baseNameOutputFiles_ = x.baseNameOutputFiles_;
    this->writeFrequency_ = x.writeFrequency_;
    this->gravInput_ = x.gravInput_;
    this->paramsLJ_ = x.paramsLJ_;
    this->boundaryConditions_ = x.boundaryConditions_;
    this->particlesLJ_ = x.particlesLJ_;
  }

  return *this;
}

input::
~input ()
{
}

// body
//

body::
body (const bodyType_type& bodyType,
      const position_type& position,
      const velocity_type& velocity,
      const objectSpecificFormat_type& objectSpecificFormat)
: ::xml_schema::type (),
  bodyType_ (bodyType, this),
  position_ (position, this),
  velocity_ (velocity, this),
  objectSpecificFormat_ (objectSpecificFormat, this)
{
}

body::
body (const body& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  bodyType_ (x.bodyType_, f, this),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  objectSpecificFormat_ (x.objectSpecificFormat_, f, this)
{
}

body::
body (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  bodyType_ (this),
  position_ (this),
  velocity_ (this),
  objectSpecificFormat_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void body::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // bodyType
    //
    if (n.name () == "bodyType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< bodyType_type > r (
        bodyType_traits::create (i, f, this));

      if (!bodyType_.present ())
      {
        this->bodyType_.set (::std::move (r));
        continue;
      }
    }

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // objectSpecificFormat
    //
    if (n.name () == "objectSpecificFormat" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< objectSpecificFormat_type > r (
        objectSpecificFormat_traits::create (i, f, this));

      if (!objectSpecificFormat_.present ())
      {
        this->objectSpecificFormat_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!bodyType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bodyType",
      "");
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!objectSpecificFormat_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "objectSpecificFormat",
      "");
  }
}

body* body::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class body (*this, f, c);
}

body& body::
operator= (const body& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->bodyType_ = x.bodyType_;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->objectSpecificFormat_ = x.objectSpecificFormat_;
  }

  return *this;
}

body::
~body ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::input >
input_ (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input_ (isrc, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input_ (isrc, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input_ (isrc, h, f, p);
}

::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::input > (
    ::input_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::input >
input_ (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::input > (
      ::input_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "input" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::input > r (
      ::xsd::cxx::tree::traits< ::input, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "input",
    "");
}

::std::unique_ptr< ::input >
input_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "input" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::input > r (
      ::xsd::cxx::tree::traits< ::input, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "input",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

