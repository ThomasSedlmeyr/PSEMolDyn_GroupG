// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from input.xsd.
 */

#ifndef INPUT_H
#define INPUT_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class bodyType;
class calcType;
class yesNo;
class parallelType;
class boundaryCondition;
class dimensionType;
class bodyState;
class thermostatType;
class gravDirectionType;
class generalParams;
class boundaryConditions;
class particlesLJ;
class input;
class body;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief Enumeration class corresponding to the %bodyType
 * schema type.
 */
class bodyType: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Cuboid,
    Tetrahedron,
    Sphere,
    Membrane
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  bodyType (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  bodyType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  bodyType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  bodyType (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bodyType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bodyType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bodyType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bodyType (const bodyType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bodyType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  bodyType&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_bodyType_convert ();
  }

  //@cond

  protected:
  value
  _xsd_bodyType_convert () const;

  public:
  static const char* const _xsd_bodyType_literals_[4];
  static const value _xsd_bodyType_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %calcType
 * schema type.
 */
class calcType: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    LJ,
    G,
    smoothedLJ
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  calcType (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  calcType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  calcType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  calcType (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  calcType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  calcType (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  calcType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  calcType (const calcType& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual calcType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  calcType&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_calcType_convert ();
  }

  //@cond

  protected:
  value
  _xsd_calcType_convert () const;

  public:
  static const char* const _xsd_calcType_literals_[3];
  static const value _xsd_calcType_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %yesNo
 * schema type.
 */
class yesNo: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    yes,
    no
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  yesNo (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  yesNo (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  yesNo (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  yesNo (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yesNo (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yesNo (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  yesNo (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  yesNo (const yesNo& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual yesNo*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  yesNo&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_yesNo_convert ();
  }

  //@cond

  protected:
  value
  _xsd_yesNo_convert () const;

  public:
  static const char* const _xsd_yesNo_literals_[2];
  static const value _xsd_yesNo_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %parallelType
 * schema type.
 */
class parallelType: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    notParallel,
    first,
    second
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  parallelType (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  parallelType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  parallelType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  parallelType (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  parallelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  parallelType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  parallelType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  parallelType (const parallelType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual parallelType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  parallelType&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_parallelType_convert ();
  }

  //@cond

  protected:
  value
  _xsd_parallelType_convert () const;

  public:
  static const char* const _xsd_parallelType_literals_[3];
  static const value _xsd_parallelType_indexes_[3];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %boundaryCondition
 * schema type.
 */
class boundaryCondition: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    outflowType,
    reflectingType,
    betterReflectingType,
    periodicType
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  boundaryCondition (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  boundaryCondition (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  boundaryCondition (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  boundaryCondition (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  boundaryCondition (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  boundaryCondition (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  boundaryCondition (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  boundaryCondition (const boundaryCondition& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual boundaryCondition*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  boundaryCondition&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_boundaryCondition_convert ();
  }

  //@cond

  protected:
  value
  _xsd_boundaryCondition_convert () const;

  public:
  static const char* const _xsd_boundaryCondition_literals_[4];
  static const value _xsd_boundaryCondition_indexes_[4];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %dimensionType
 * schema type.
 */
class dimensionType: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    cxx_2D,
    cxx_3D
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  dimensionType (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  dimensionType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  dimensionType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  dimensionType (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  dimensionType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  dimensionType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  dimensionType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  dimensionType (const dimensionType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual dimensionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  dimensionType&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_dimensionType_convert ();
  }

  //@cond

  protected:
  value
  _xsd_dimensionType_convert () const;

  public:
  static const char* const _xsd_dimensionType_literals_[2];
  static const value _xsd_dimensionType_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %bodyState
 * schema type.
 */
class bodyState: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    fixed,
    moving
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  bodyState (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  bodyState (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  bodyState (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  bodyState (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bodyState (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bodyState (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  bodyState (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  bodyState (const bodyState& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual bodyState*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  bodyState&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_bodyState_convert ();
  }

  //@cond

  protected:
  value
  _xsd_bodyState_convert () const;

  public:
  static const char* const _xsd_bodyState_literals_[2];
  static const value _xsd_bodyState_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %thermostatType
 * schema type.
 */
class thermostatType: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    regular,
    onlyFluid
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  thermostatType (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  thermostatType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  thermostatType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  thermostatType (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  thermostatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  thermostatType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  thermostatType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  thermostatType (const thermostatType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual thermostatType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  thermostatType&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_thermostatType_convert ();
  }

  //@cond

  protected:
  value
  _xsd_thermostatType_convert () const;

  public:
  static const char* const _xsd_thermostatType_literals_[2];
  static const value _xsd_thermostatType_indexes_[2];

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %gravDirectionType
 * schema type.
 */
class gravDirectionType: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    x,
    y,
    z
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  gravDirectionType (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  gravDirectionType (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  gravDirectionType (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  gravDirectionType (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  gravDirectionType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  gravDirectionType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  gravDirectionType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  gravDirectionType (const gravDirectionType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual gravDirectionType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  gravDirectionType&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_gravDirectionType_convert ();
  }

  //@cond

  protected:
  value
  _xsd_gravDirectionType_convert () const;

  public:
  static const char* const _xsd_gravDirectionType_literals_[3];
  static const value _xsd_gravDirectionType_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %generalParams schema type.
 *
 * @nosubgrouping
 */
class generalParams: public ::xml_schema::type
{
  public:
  /**
   * @name t_end
   *
   * @brief Accessor and modifier functions for the %t_end
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ t_end_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< t_end_type, char, ::xsd::cxx::tree::schema_type::double_ > t_end_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const t_end_type&
  t_end () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  t_end_type&
  t_end ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  t_end (const t_end_type& x);

  //@}

  /**
   * @name delta_t
   *
   * @brief Accessor and modifier functions for the %delta_t
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ delta_t_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< delta_t_type, char, ::xsd::cxx::tree::schema_type::double_ > delta_t_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const delta_t_type&
  delta_t () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  delta_t_type&
  delta_t ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  delta_t (const delta_t_type& x);

  //@}

  /**
   * @name writeFrequency
   *
   * @brief Accessor and modifier functions for the %writeFrequency
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ writeFrequency_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< writeFrequency_type, char > writeFrequency_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const writeFrequency_type&
  writeFrequency () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  writeFrequency_type&
  writeFrequency ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  writeFrequency (const writeFrequency_type& x);

  //@}

  /**
   * @name dimensionType
   *
   * @brief Accessor and modifier functions for the %dimensionType
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::dimensionType dimensionType_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dimensionType_type, char > dimensionType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const dimensionType_type&
  dimensionType () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  dimensionType_type&
  dimensionType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dimensionType (const dimensionType_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  dimensionType (::std::unique_ptr< dimensionType_type > p);

  //@}

  /**
   * @name parallelType
   *
   * @brief Accessor and modifier functions for the %parallelType
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::parallelType parallelType_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< parallelType_type, char > parallelType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const parallelType_type&
  parallelType () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  parallelType_type&
  parallelType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  parallelType (const parallelType_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  parallelType (::std::unique_ptr< parallelType_type > p);

  //@}

  /**
   * @name g_grav
   *
   * @brief Accessor and modifier functions for the %g_grav
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ g_grav_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< g_grav_type, char, ::xsd::cxx::tree::schema_type::double_ > g_grav_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const g_grav_type&
  g_grav () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  g_grav_type&
  g_grav ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  g_grav (const g_grav_type& x);

  //@}

  /**
   * @name useGravity
   *
   * @brief Accessor and modifier functions for the %useGravity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::yesNo useGravity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< useGravity_type, char > useGravity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const useGravity_type&
  useGravity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  useGravity_type&
  useGravity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  useGravity (const useGravity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  useGravity (::std::unique_ptr< useGravity_type > p);

  //@}

  /**
   * @name gravDirection
   *
   * @brief Accessor and modifier functions for the %gravDirection
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::gravDirectionType gravDirection_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gravDirection_type, char > gravDirection_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const gravDirection_type&
  gravDirection () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  gravDirection_type&
  gravDirection ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gravDirection (const gravDirection_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  gravDirection (::std::unique_ptr< gravDirection_type > p);

  //@}

  /**
   * @name calcType
   *
   * @brief Accessor and modifier functions for the %calcType
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::calcType calcType_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< calcType_type, char > calcType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const calcType_type&
  calcType () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  calcType_type&
  calcType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  calcType (const calcType_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  calcType (::std::unique_ptr< calcType_type > p);

  //@}

  /**
   * @name baseNameOutputFiles
   *
   * @brief Accessor and modifier functions for the %baseNameOutputFiles
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string baseNameOutputFiles_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< baseNameOutputFiles_type, char > baseNameOutputFiles_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const baseNameOutputFiles_type&
  baseNameOutputFiles () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  baseNameOutputFiles_type&
  baseNameOutputFiles ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  baseNameOutputFiles (const baseNameOutputFiles_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  baseNameOutputFiles (::std::unique_ptr< baseNameOutputFiles_type > p);

  //@}

  /**
   * @name cutoffRadius
   *
   * @brief Accessor and modifier functions for the %cutoffRadius
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ cutoffRadius_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cutoffRadius_type, char, ::xsd::cxx::tree::schema_type::double_ > cutoffRadius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const cutoffRadius_type&
  cutoffRadius () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  cutoffRadius_type&
  cutoffRadius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  cutoffRadius (const cutoffRadius_type& x);

  //@}

  /**
   * @name gravInput
   *
   * @brief Accessor and modifier functions for the %gravInput
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string gravInput_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gravInput_type, char > gravInput_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const gravInput_type&
  gravInput () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  gravInput_type&
  gravInput ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gravInput (const gravInput_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  gravInput (::std::unique_ptr< gravInput_type > p);

  //@}

  /**
   * @name loadCheckpoint
   *
   * @brief Accessor and modifier functions for the %loadCheckpoint
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::yesNo loadCheckpoint_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< loadCheckpoint_type, char > loadCheckpoint_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const loadCheckpoint_type&
  loadCheckpoint () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  loadCheckpoint_type&
  loadCheckpoint ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  loadCheckpoint (const loadCheckpoint_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  loadCheckpoint (::std::unique_ptr< loadCheckpoint_type > p);

  //@}

  /**
   * @name makeCheckpoint
   *
   * @brief Accessor and modifier functions for the %makeCheckpoint
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::yesNo makeCheckpoint_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< makeCheckpoint_type, char > makeCheckpoint_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const makeCheckpoint_type&
  makeCheckpoint () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  makeCheckpoint_type&
  makeCheckpoint ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  makeCheckpoint (const makeCheckpoint_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  makeCheckpoint (::std::unique_ptr< makeCheckpoint_type > p);

  //@}

  /**
   * @name pathInCheckpoint
   *
   * @brief Accessor and modifier functions for the %pathInCheckpoint
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string pathInCheckpoint_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< pathInCheckpoint_type, char > pathInCheckpoint_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const pathInCheckpoint_type&
  pathInCheckpoint () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  pathInCheckpoint_type&
  pathInCheckpoint ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  pathInCheckpoint (const pathInCheckpoint_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  pathInCheckpoint (::std::unique_ptr< pathInCheckpoint_type > p);

  //@}

  /**
   * @name pathOutCheckpoint
   *
   * @brief Accessor and modifier functions for the %pathOutCheckpoint
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string pathOutCheckpoint_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< pathOutCheckpoint_type, char > pathOutCheckpoint_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const pathOutCheckpoint_type&
  pathOutCheckpoint () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  pathOutCheckpoint_type&
  pathOutCheckpoint ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  pathOutCheckpoint (const pathOutCheckpoint_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  pathOutCheckpoint (::std::unique_ptr< pathOutCheckpoint_type > p);

  //@}

  /**
   * @name domainSizeX
   *
   * @brief Accessor and modifier functions for the %domainSizeX
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ domainSizeX_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< domainSizeX_type, char, ::xsd::cxx::tree::schema_type::double_ > domainSizeX_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const domainSizeX_type&
  domainSizeX () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  domainSizeX_type&
  domainSizeX ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  domainSizeX (const domainSizeX_type& x);

  //@}

  /**
   * @name domainSizeY
   *
   * @brief Accessor and modifier functions for the %domainSizeY
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ domainSizeY_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< domainSizeY_type, char, ::xsd::cxx::tree::schema_type::double_ > domainSizeY_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const domainSizeY_type&
  domainSizeY () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  domainSizeY_type&
  domainSizeY ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  domainSizeY (const domainSizeY_type& x);

  //@}

  /**
   * @name domainSizeZ
   *
   * @brief Accessor and modifier functions for the %domainSizeZ
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ domainSizeZ_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< domainSizeZ_type, char, ::xsd::cxx::tree::schema_type::double_ > domainSizeZ_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const domainSizeZ_type&
  domainSizeZ () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  domainSizeZ_type&
  domainSizeZ ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  domainSizeZ (const domainSizeZ_type& x);

  //@}

  /**
   * @name useThermostat
   *
   * @brief Accessor and modifier functions for the %useThermostat
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::yesNo useThermostat_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< useThermostat_type, char > useThermostat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const useThermostat_type&
  useThermostat () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  useThermostat_type&
  useThermostat ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  useThermostat (const useThermostat_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  useThermostat (::std::unique_ptr< useThermostat_type > p);

  //@}

  /**
   * @name thermostatType
   *
   * @brief Accessor and modifier functions for the %thermostatType
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::thermostatType thermostatType_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< thermostatType_type, char > thermostatType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const thermostatType_type&
  thermostatType () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  thermostatType_type&
  thermostatType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  thermostatType (const thermostatType_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  thermostatType (::std::unique_ptr< thermostatType_type > p);

  //@}

  /**
   * @name useBrownianMotion
   *
   * @brief Accessor and modifier functions for the %useBrownianMotion
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::yesNo useBrownianMotion_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< useBrownianMotion_type, char > useBrownianMotion_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const useBrownianMotion_type&
  useBrownianMotion () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  useBrownianMotion_type&
  useBrownianMotion ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  useBrownianMotion (const useBrownianMotion_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  useBrownianMotion (::std::unique_ptr< useBrownianMotion_type > p);

  //@}

  /**
   * @name T_init
   *
   * @brief Accessor and modifier functions for the %T_init
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ T_init_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< T_init_type, char, ::xsd::cxx::tree::schema_type::double_ > T_init_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const T_init_type&
  T_init () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  T_init_type&
  T_init ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  T_init (const T_init_type& x);

  //@}

  /**
   * @name T_target
   *
   * @brief Accessor and modifier functions for the %T_target
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ T_target_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< T_target_type, char, ::xsd::cxx::tree::schema_type::double_ > T_target_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const T_target_type&
  T_target () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  T_target_type&
  T_target ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  T_target (const T_target_type& x);

  //@}

  /**
   * @name delta_T
   *
   * @brief Accessor and modifier functions for the %delta_T
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ delta_T_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< delta_T_type, char, ::xsd::cxx::tree::schema_type::double_ > delta_T_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const delta_T_type&
  delta_T () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  delta_T_type&
  delta_T ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  delta_T (const delta_T_type& x);

  //@}

  /**
   * @name n_thermostat
   *
   * @brief Accessor and modifier functions for the %n_thermostat
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ n_thermostat_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< n_thermostat_type, char, ::xsd::cxx::tree::schema_type::double_ > n_thermostat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const n_thermostat_type&
  n_thermostat () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  n_thermostat_type&
  n_thermostat ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  n_thermostat (const n_thermostat_type& x);

  //@}

  /**
   * @name useProfiling
   *
   * @brief Accessor and modifier functions for the %useProfiling
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::yesNo useProfiling_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< useProfiling_type, char > useProfiling_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const useProfiling_type&
  useProfiling () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  useProfiling_type&
  useProfiling ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  useProfiling (const useProfiling_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  useProfiling (::std::unique_ptr< useProfiling_type > p);

  //@}

  /**
   * @name numberOfBins
   *
   * @brief Accessor and modifier functions for the %numberOfBins
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ numberOfBins_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< numberOfBins_type, char > numberOfBins_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const numberOfBins_type&
  numberOfBins () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  numberOfBins_type&
  numberOfBins ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  numberOfBins (const numberOfBins_type& x);

  //@}

  /**
   * @name pathToAnalysisFolder
   *
   * @brief Accessor and modifier functions for the %pathToAnalysisFolder
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string pathToAnalysisFolder_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< pathToAnalysisFolder_type, char > pathToAnalysisFolder_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const pathToAnalysisFolder_type&
  pathToAnalysisFolder () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  pathToAnalysisFolder_type&
  pathToAnalysisFolder ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  pathToAnalysisFolder (const pathToAnalysisFolder_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  pathToAnalysisFolder (::std::unique_ptr< pathToAnalysisFolder_type > p);

  //@}

  /**
   * @name crystallization_r_c
   *
   * @brief Accessor and modifier functions for the %crystallization_r_c
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ crystallization_r_c_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< crystallization_r_c_type, char, ::xsd::cxx::tree::schema_type::double_ > crystallization_r_c_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const crystallization_r_c_type&
  crystallization_r_c () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  crystallization_r_c_type&
  crystallization_r_c ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  crystallization_r_c (const crystallization_r_c_type& x);

  //@}

  /**
   * @name crystallization_r_l
   *
   * @brief Accessor and modifier functions for the %crystallization_r_l
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ crystallization_r_l_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< crystallization_r_l_type, char, ::xsd::cxx::tree::schema_type::double_ > crystallization_r_l_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const crystallization_r_l_type&
  crystallization_r_l () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  crystallization_r_l_type&
  crystallization_r_l ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  crystallization_r_l (const crystallization_r_l_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  generalParams (const t_end_type&,
                 const delta_t_type&,
                 const writeFrequency_type&,
                 const dimensionType_type&,
                 const parallelType_type&,
                 const g_grav_type&,
                 const useGravity_type&,
                 const gravDirection_type&,
                 const calcType_type&,
                 const baseNameOutputFiles_type&,
                 const cutoffRadius_type&,
                 const gravInput_type&,
                 const loadCheckpoint_type&,
                 const makeCheckpoint_type&,
                 const pathInCheckpoint_type&,
                 const pathOutCheckpoint_type&,
                 const domainSizeX_type&,
                 const domainSizeY_type&,
                 const domainSizeZ_type&,
                 const useThermostat_type&,
                 const thermostatType_type&,
                 const useBrownianMotion_type&,
                 const T_init_type&,
                 const T_target_type&,
                 const delta_T_type&,
                 const n_thermostat_type&,
                 const useProfiling_type&,
                 const numberOfBins_type&,
                 const pathToAnalysisFolder_type&,
                 const crystallization_r_c_type&,
                 const crystallization_r_l_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  generalParams (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  generalParams (const generalParams& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual generalParams*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  generalParams&
  operator= (const generalParams& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~generalParams ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< t_end_type > t_end_;
  ::xsd::cxx::tree::one< delta_t_type > delta_t_;
  ::xsd::cxx::tree::one< writeFrequency_type > writeFrequency_;
  ::xsd::cxx::tree::one< dimensionType_type > dimensionType_;
  ::xsd::cxx::tree::one< parallelType_type > parallelType_;
  ::xsd::cxx::tree::one< g_grav_type > g_grav_;
  ::xsd::cxx::tree::one< useGravity_type > useGravity_;
  ::xsd::cxx::tree::one< gravDirection_type > gravDirection_;
  ::xsd::cxx::tree::one< calcType_type > calcType_;
  ::xsd::cxx::tree::one< baseNameOutputFiles_type > baseNameOutputFiles_;
  ::xsd::cxx::tree::one< cutoffRadius_type > cutoffRadius_;
  ::xsd::cxx::tree::one< gravInput_type > gravInput_;
  ::xsd::cxx::tree::one< loadCheckpoint_type > loadCheckpoint_;
  ::xsd::cxx::tree::one< makeCheckpoint_type > makeCheckpoint_;
  ::xsd::cxx::tree::one< pathInCheckpoint_type > pathInCheckpoint_;
  ::xsd::cxx::tree::one< pathOutCheckpoint_type > pathOutCheckpoint_;
  ::xsd::cxx::tree::one< domainSizeX_type > domainSizeX_;
  ::xsd::cxx::tree::one< domainSizeY_type > domainSizeY_;
  ::xsd::cxx::tree::one< domainSizeZ_type > domainSizeZ_;
  ::xsd::cxx::tree::one< useThermostat_type > useThermostat_;
  ::xsd::cxx::tree::one< thermostatType_type > thermostatType_;
  ::xsd::cxx::tree::one< useBrownianMotion_type > useBrownianMotion_;
  ::xsd::cxx::tree::one< T_init_type > T_init_;
  ::xsd::cxx::tree::one< T_target_type > T_target_;
  ::xsd::cxx::tree::one< delta_T_type > delta_T_;
  ::xsd::cxx::tree::one< n_thermostat_type > n_thermostat_;
  ::xsd::cxx::tree::one< useProfiling_type > useProfiling_;
  ::xsd::cxx::tree::one< numberOfBins_type > numberOfBins_;
  ::xsd::cxx::tree::one< pathToAnalysisFolder_type > pathToAnalysisFolder_;
  ::xsd::cxx::tree::one< crystallization_r_c_type > crystallization_r_c_;
  ::xsd::cxx::tree::one< crystallization_r_l_type > crystallization_r_l_;

  //@endcond
};

/**
 * @brief Class corresponding to the %boundaryConditions schema type.
 *
 * @nosubgrouping
 */
class boundaryConditions: public ::xml_schema::type
{
  public:
  /**
   * @name top
   *
   * @brief Accessor and modifier functions for the %top
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaryCondition top_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< top_type, char > top_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const top_type&
  top () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  top_type&
  top ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  top (const top_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  top (::std::unique_ptr< top_type > p);

  //@}

  /**
   * @name right
   *
   * @brief Accessor and modifier functions for the %right
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaryCondition right_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< right_type, char > right_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const right_type&
  right () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  right_type&
  right ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  right (const right_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  right (::std::unique_ptr< right_type > p);

  //@}

  /**
   * @name bottom
   *
   * @brief Accessor and modifier functions for the %bottom
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaryCondition bottom_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< bottom_type, char > bottom_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bottom_type&
  bottom () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bottom_type&
  bottom ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  bottom (const bottom_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  bottom (::std::unique_ptr< bottom_type > p);

  //@}

  /**
   * @name left
   *
   * @brief Accessor and modifier functions for the %left
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaryCondition left_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< left_type, char > left_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const left_type&
  left () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  left_type&
  left ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  left (const left_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  left (::std::unique_ptr< left_type > p);

  //@}

  /**
   * @name front
   *
   * @brief Accessor and modifier functions for the %front
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaryCondition front_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< front_type, char > front_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const front_type&
  front () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  front_type&
  front ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  front (const front_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  front (::std::unique_ptr< front_type > p);

  //@}

  /**
   * @name back
   *
   * @brief Accessor and modifier functions for the %back
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaryCondition back_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< back_type, char > back_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const back_type&
  back () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  back_type&
  back ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  back (const back_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  back (::std::unique_ptr< back_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  boundaryConditions (const top_type&,
                      const right_type&,
                      const bottom_type&,
                      const left_type&,
                      const front_type&,
                      const back_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  boundaryConditions (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  boundaryConditions (const boundaryConditions& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual boundaryConditions*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  boundaryConditions&
  operator= (const boundaryConditions& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~boundaryConditions ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< top_type > top_;
  ::xsd::cxx::tree::one< right_type > right_;
  ::xsd::cxx::tree::one< bottom_type > bottom_;
  ::xsd::cxx::tree::one< left_type > left_;
  ::xsd::cxx::tree::one< front_type > front_;
  ::xsd::cxx::tree::one< back_type > back_;

  //@endcond
};

/**
 * @brief Class corresponding to the %particlesLJ schema type.
 *
 * @nosubgrouping
 */
class particlesLJ: public ::xml_schema::type
{
  public:
  /**
   * @name body
   *
   * @brief Accessor and modifier functions for the %body
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::body body_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< body_type > body_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef body_sequence::iterator body_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef body_sequence::const_iterator body_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< body_type, char > body_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const body_sequence&
  body () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  body_sequence&
  body ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  body (const body_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  particlesLJ ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  particlesLJ (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  particlesLJ (const particlesLJ& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual particlesLJ*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  particlesLJ&
  operator= (const particlesLJ& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~particlesLJ ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  body_sequence body_;

  //@endcond
};

/**
 * @brief Class corresponding to the %input schema type.
 *
 * @nosubgrouping
 */
class input: public ::xml_schema::type
{
  public:
  /**
   * @name generalParams
   *
   * @brief Accessor and modifier functions for the %generalParams
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::generalParams generalParams_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< generalParams_type, char > generalParams_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const generalParams_type&
  generalParams () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  generalParams_type&
  generalParams ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  generalParams (const generalParams_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  generalParams (::std::unique_ptr< generalParams_type > p);

  //@}

  /**
   * @name boundaryConditions
   *
   * @brief Accessor and modifier functions for the %boundaryConditions
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::boundaryConditions boundaryConditions_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< boundaryConditions_type, char > boundaryConditions_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const boundaryConditions_type&
  boundaryConditions () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  boundaryConditions_type&
  boundaryConditions ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  boundaryConditions (const boundaryConditions_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  boundaryConditions (::std::unique_ptr< boundaryConditions_type > p);

  //@}

  /**
   * @name particlesLJ
   *
   * @brief Accessor and modifier functions for the %particlesLJ
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::particlesLJ particlesLJ_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< particlesLJ_type, char > particlesLJ_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const particlesLJ_type&
  particlesLJ () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  particlesLJ_type&
  particlesLJ ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  particlesLJ (const particlesLJ_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  particlesLJ (::std::unique_ptr< particlesLJ_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  input (const generalParams_type&,
         const boundaryConditions_type&,
         const particlesLJ_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  input (::std::unique_ptr< generalParams_type >,
         ::std::unique_ptr< boundaryConditions_type >,
         ::std::unique_ptr< particlesLJ_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  input (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  input (const input& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual input*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  input&
  operator= (const input& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~input ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< generalParams_type > generalParams_;
  ::xsd::cxx::tree::one< boundaryConditions_type > boundaryConditions_;
  ::xsd::cxx::tree::one< particlesLJ_type > particlesLJ_;

  //@endcond
};

/**
 * @brief Class corresponding to the %body schema type.
 *
 * @nosubgrouping
 */
class body: public ::xml_schema::type
{
  public:
  /**
   * @name bodyType
   *
   * @brief Accessor and modifier functions for the %bodyType
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::bodyType bodyType_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< bodyType_type, char > bodyType_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bodyType_type&
  bodyType () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bodyType_type&
  bodyType ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  bodyType (const bodyType_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  bodyType (::std::unique_ptr< bodyType_type > p);

  //@}

  /**
   * @name position
   *
   * @brief Accessor and modifier functions for the %position
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string position_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< position_type, char > position_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const position_type&
  position () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  position_type&
  position ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  position (const position_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  position (::std::unique_ptr< position_type > p);

  //@}

  /**
   * @name velocity
   *
   * @brief Accessor and modifier functions for the %velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< velocity_type, char > velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const velocity_type&
  velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  velocity_type&
  velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  velocity (const velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  velocity (::std::unique_ptr< velocity_type > p);

  //@}

  /**
   * @name objectSpecificFormat
   *
   * @brief Accessor and modifier functions for the %objectSpecificFormat
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string objectSpecificFormat_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< objectSpecificFormat_type, char > objectSpecificFormat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const objectSpecificFormat_type&
  objectSpecificFormat () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  objectSpecificFormat_type&
  objectSpecificFormat ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  objectSpecificFormat (const objectSpecificFormat_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  objectSpecificFormat (::std::unique_ptr< objectSpecificFormat_type > p);

  //@}

  /**
   * @name epsilon
   *
   * @brief Accessor and modifier functions for the %epsilon
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ epsilon_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const epsilon_type&
  epsilon () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  epsilon_type&
  epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon (const epsilon_type& x);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char, ::xsd::cxx::tree::schema_type::double_ > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  //@}

  /**
   * @name rho
   *
   * @brief Accessor and modifier functions for the %rho
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ rho_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< rho_type, char, ::xsd::cxx::tree::schema_type::double_ > rho_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const rho_type&
  rho () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  rho_type&
  rho ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  rho (const rho_type& x);

  //@}

  /**
   * @name h
   *
   * @brief Accessor and modifier functions for the %h
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ h_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< h_type, char, ::xsd::cxx::tree::schema_type::double_ > h_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const h_type&
  h () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  h_type&
  h ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  h (const h_type& x);

  //@}

  /**
   * @name bodyState
   *
   * @brief Accessor and modifier functions for the %bodyState
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::bodyState bodyState_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< bodyState_type, char > bodyState_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bodyState_type&
  bodyState () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bodyState_type&
  bodyState ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  bodyState (const bodyState_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  bodyState (::std::unique_ptr< bodyState_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  body (const bodyType_type&,
        const position_type&,
        const velocity_type&,
        const objectSpecificFormat_type&,
        const epsilon_type&,
        const mass_type&,
        const rho_type&,
        const h_type&,
        const bodyState_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  body (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  body (const body& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual body*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  body&
  operator= (const body& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~body ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< bodyType_type > bodyType_;
  ::xsd::cxx::tree::one< position_type > position_;
  ::xsd::cxx::tree::one< velocity_type > velocity_;
  ::xsd::cxx::tree::one< objectSpecificFormat_type > objectSpecificFormat_;
  ::xsd::cxx::tree::one< epsilon_type > epsilon_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< rho_type > rho_;
  ::xsd::cxx::tree::one< h_type > h_;
  ::xsd::cxx::tree::one< bodyState_type > bodyState_;

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %input document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::input >
input_ (const ::std::string& uri,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (const ::std::string& uri,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (const ::std::string& uri,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (::std::istream& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& id,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (::std::istream& is,
        const ::std::string& id,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& is,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& is,
        ::xml_schema::error_handler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::input >
input_ (::xercesc::InputSource& is,
        ::xercesc::DOMErrorHandler& eh,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::input >
input_ (const ::xercesc::DOMDocument& d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::input >
input_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f = 0,
        const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // INPUT_H
